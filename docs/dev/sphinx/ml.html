<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Machine Learning &mdash; libSkylark  documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="libSkylark  documentation" href="index.html" />
    <link rel="next" title="IO in libSkylark" href="io.html" />
    <link rel="prev" title="Numerical Linear Algebra Primitives" href="nla.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>libSkylark  documentation</span></a></h1>
        <h2 class="heading"><span>Machine Learning</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="nla.html">Numerical Linear Algebra Primitives</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="io.html">IO in libSkylark</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="machine-learning">
<h1>Machine Learning<a class="headerlink" href="#machine-learning" title="Permalink to this headline">¶</a></h1>
<div class="section" id="randomized-kernel-methods">
<h2>Randomized Kernel Methods<a class="headerlink" href="#randomized-kernel-methods" title="Permalink to this headline">¶</a></h2>
<p>libSkylark provides distributed implementations of kernel-based nonlinear models for</p>
<blockquote>
<div><ul class="simple">
<li>Regularized Least Squares Regression and Classification</li>
<li>Regularized Robust Regression (Least Absolute Deviation loss)</li>
<li>Support Vector Machines</li>
<li>Multinomial Logistic Regression (classes &gt; 2).</li>
</ul>
</div></blockquote>
<p>The following kernels are supported:</p>
<blockquote>
<div><ul class="simple">
<li>Gaussian and Laplacian Kernels via Random Fourier Transform (<a class="reference external" href="http://www.eecs.berkeley.edu/~brecht/papers/07.rah.rec.nips.pdf">Rahimi and Recht, 2007</a>)</li>
<li>Gaussian and Laplacian Kernels via Fast Random Fourier Transform (<a class="reference external" href="http://jmlr.org/proceedings/papers/v28/le13.html">Le, Sarlos and Smola, 2013</a>)</li>
<li>Polynomial Kernels via Tensor Sketch (<a class="reference external" href="http://www.itu.dk/people/ndap/TensorSketch.pdf">Pahm and Pagh, 2013</a>)</li>
<li>Exponential Semigroup Kernels via Random Laplace Transform (<a class="reference external" href="http://vikas.sindhwani.org/RandomLaplace.pdf">Yang et al, 2014</a>)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>The implementations combine two ideas:</dt>
<dd><ul class="first last simple">
<li>Constructing randomized approximations to Kernel functions <em>on the fly</em></li>
<li>Using a distributed optimization solver based on Alternating Directions Method of Multipliers (ADMM)</li>
</ul>
</dd>
</dl>
<p>The distributed optimization approach is based on a block-splitting variant of ADMM proposed in <a class="reference external" href="http://web.stanford.edu/~boyd/papers/block_splitting.html">Parikh and Boyd, 2014</a></p>
<dl class="docutils">
<dt>The full implementation (under <code class="docutils literal"><span class="pre">libskylark/ml</span></code>) is described in the following paper:</dt>
<dd><ul class="first last simple">
<li>Sindhwani V. and Avron H., High-performance Kernel Machines with Implicit Distributed Optimization and Randomization, 2014</li>
</ul>
</dd>
</dl>
<div class="section" id="standalone-usage">
<h3>Standalone Usage<a class="headerlink" href="#standalone-usage" title="Permalink to this headline">¶</a></h3>
<p>Building libSkylark creates an executable called <strong>skylark_ml</strong> under CMAKE_PREFIX_INSTALL/bin. This executable can be
used out-of-the-box for large-scale applications involving kernel-based modeling.</p>
</div>
<div class="section" id="input-data-format">
<span id="ml-io"></span><h3>Input Data Format<a class="headerlink" href="#input-data-format" title="Permalink to this headline">¶</a></h3>
<p>The implementation supports <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/">LIBSVM</a> file format, where
feature vectors and labels are specified as</p>
<div class="highlight-python"><div class="highlight"><pre>0 1:0.2 4:0.5 10:0.3
5 3:0.3 6:0.1
</pre></div>
</div>
<p>Each line begins with a label and followed by index (starting with 1)-value pairs describing the feature vector in
sparse format.</p>
<p>We also support <a class="reference external" href="http://www.hdfgroup.org/HDF5/">HDF5</a> data files.</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>Dense training data can be described using HDF5 files containing two <a class="reference external" href="http://www.hdfgroup.org/HDF5/Tutor/crtdat.html">HDF5 datasets</a>:</dt>
<dd><ul class="first last simple">
<li><em>X</em> &#8211; n x d matrix  (examples-by-features)</li>
<li><em>Y</em> &#8211; n x 1 matrix of labels.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Sparse training data can be described using HDF5 files containing five <a class="reference external" href="http://www.hdfgroup.org/HDF5/Tutor/crtdat.html">HDF5 datasets</a> specifying a Compressed Row Storage Sparse matrix:</dt>
<dd><ul class="first last simple">
<li><em>dimensions</em>: 3 x 1 matrix [number of features, number of examples, number of nonzeros (nnz)]</li>
<li><em>indices</em>: nnz x 1 matrix column indices of non-zero values for CRS datastructure representing the examples-by-features sparse matrix</li>
<li><em>values</em>: nnz x 1 non-zero values corresponding to indices</li>
<li><em>indptr</em>: (n+1) x 1 - pointer into indices, values specifying rows</li>
<li><em>Y</em>: n x 1 matrix of labels</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Examples of such files can be downloaded from <a class="reference external" href="http://vikas.sindhwani.org/data.tar.gz">here</a>. The HDF5 files can be viewed using <a class="reference external" href="http://http://www.hdfgroup.org/HDF5/Tutor/hdfview.html">HDFView</a>. A screenshot is shown below.</p>
<a class="reference internal image-reference" href="_images/hdfview_screenshot.png"><img alt="_images/hdfview_screenshot.png" class="align-center" src="_images/hdfview_screenshot.png" style="width: 750px;" /></a>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For all fileformats described above, the current implementation is geared towards classification problems and requires the label to assume values from 0 to (K-1) for a K-class problem, or +1/-1 for binary classification problems. This assumption will be relaxed.</p>
</div>
</div>
<div class="section" id="example-and-commandline-usage">
<h3>Example and Commandline Usage<a class="headerlink" href="#example-and-commandline-usage" title="Permalink to this headline">¶</a></h3>
<p>Please see <a class="reference internal" href="quick_start.html#ml-example"><em>ML</em></a></p>
<div class="highlight-python"><div class="highlight"><pre>Training mode usage: skylark_ml [options] --trainfile trainfile --modelfile modelfile
Testing mode usage: skylark_ml --modelfile modelfile --testfile testfile
  -h [ --help ]                         produce a help message
  -l [ --lossfunction ] arg (=0)        Loss function (0:SQUARED (L2), 1:LAD
                                        (L1), 2:HINGE, 3:LOGISTIC)
  -r [ --regularizer ] arg (=0)         Regularizer (0:L2, 1:L1)
  -k [ --kernel ] arg (=0)              Kernel (1:GAUSSIAN,
                                        2:POLYNOMIAL, 3:LAPLACIAN,
                                        4:EXPSEMIGROUP)
  -g [ --kernelparam ] arg (=1)         Kernel Parameter
  -x [ --kernelparam2 ] arg (=0)        If Applicable - Second Kernel Parameter
                                        (Polynomial Kernel: c)
  -y [ --kernelparam3 ] arg (=1)        If Applicable - Third Kernel Parameter
                                        (Polynomial Kernel: gamma)
  -c [ --lambda ] arg (=0)              Regularization Parameter
  -e [ --tolerance ] arg (=0.001)       Tolerance
  --rho arg (=1)                        ADMM rho parameter
  -s [ --seed ] arg (=12345)            Seed for Random Number Generator
  -f [ --randomfeatures ] arg (=100)    Number of Random Features (default:
                                        100)
  -n [ --numfeaturepartitions ] arg (=1)
                                        Number of Feature Partitions (default:
                                        1)
  -t [ --numthreads ] arg (=1)          Number of Threads (default: 1)
  --regular arg (=1)                    Default is to use &#39;fast&#39; feature
                                        mapping, if available.Use this flag to
                                        force regular mapping (default: false)
  --cachetransforms arg (=0)            Default is to not cache feature
                                        transforms per iteration, but generate
                                        on fly. Use this flag to force
                                        transform caching if you have enough
                                        memory (default: false)
  --fileformat arg (=0)                 Fileformat (default: 0 (libsvm-&gt;dense),
                                        1 (libsvm-&gt;sparse), 2 (hdf5-&gt;dense), 3
                                        (hdf5-&gt;sparse)
  -i [ --MAXITER ] arg (=100)           Maximum Number of Iterations (default:
                                        100)
  --trainfile arg                       Training data file (required in
                                        training mode)
  --modelfile arg                       Model output file
  --valfile arg                         Validation file (optional)
  --testfile arg                        Test file (optional in training mode;
                                        required in testing mode)
</pre></div>
</div>
</div>
<div class="section" id="library-usage">
<h3>Library Usage<a class="headerlink" href="#library-usage" title="Permalink to this headline">¶</a></h3>
<p>To be documented (please see <code class="docutils literal"><span class="pre">ml/run.hpp</span></code> for a driver program).</p>
</div>
</div>
<div class="section" id="local-graph-computations">
<h2>Local Graph Computations<a class="headerlink" href="#local-graph-computations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="community-detection-using-seed-nodes">
<h3>Community Detection using Seed Nodes<a class="headerlink" href="#community-detection-using-seed-nodes" title="Permalink to this headline">¶</a></h3>
<p>In community detection problems (i.e., graph clustering problems), one seeks to identify a set
of nodes in a graph that are both internally cohesive and also well separated from the remainder
of the graph. Such sets are then referred to as communities or clusters. In one important variant
of community detection, the goal is to build a community around a given seed node or set of seed
nodes. That is, the algorithm is given, as an input, a node (or nodes) in the graph, and the
goal is to find a cluster in which it is a member.</p>
<dl class="docutils">
<dt>The library implements the algorithm reported in the following paper:</dt>
<dd><ul class="first last">
<li><div class="first line-block">
<div class="line">H. Avron and L. Horesh</div>
<div class="line">Community Detection Using Time-Dependent Personalized PageRank</div>
</div>
</li>
</ul>
</dd>
</dl>
<p>The interface is as follows:</p>
<dl class="function">
<dt id="_CPP16FindLocalClusterRK9GraphTypeRKNSt13unordered_setIN9GraphType11vertex_typeEEERNSt13unordered_setIN9GraphType11vertex_typeEEEdddib">
double <code class="descclassname"></code><code class="descname">FindLocalCluster</code><span class="sig-paren">(</span><em class="property">const</em> GraphType &amp;<em>G</em>, <em class="property">const</em> std::unordered_set&lt;<em class="property">typename</em> GraphType::<a class="reference internal" href="#_CPPN9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>&gt; &amp;<em>seeds</em>, std::unordered_set&lt;<em class="property">typename</em> GraphType::<a class="reference internal" href="#_CPPN9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>&gt; &amp;<em>cluster</em>, double <em>alpha</em>, double <em>gamma</em>, double <em>epsilon</em>, int <em>NX</em>, bool <em>recursive</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPP16FindLocalClusterRK9GraphTypeRKNSt13unordered_setIN9GraphType11vertex_typeEEERNSt13unordered_setIN9GraphType11vertex_typeEEEdddib" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>seeds is the set of input seeds, cluster is the set of output cluster. alpha, gamma, epsilon and NX are
parameters of the algorithm. See paper for details. Defaults are specified.
If recursive is set to true (default is false)
the algorithm will recursively use the output cluster as seed until the cluster stops
improving (as measured using conductance).</p>
<p>The graph is specified using parameter G. The type is generic: the GraphType class is expected to
support the following:</p>
<dl class="type">
<dt id="_CPPN9GraphType11vertex_typeE">
<em class="property">type </em><code class="descclassname">GraphType::</code><code class="descname">vertex_type</code><a class="headerlink" href="#_CPPN9GraphType11vertex_typeE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Type of the graph nodes</p>
<dl class="function">
<dt id="_CPPN9GraphType9num_edgesEv">
size_t <code class="descclassname">GraphType::</code><code class="descname">num_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPN9GraphType9num_edgesEv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return the number of edges in the graph.</p>
<dl class="function">
<dt id="_CPPN9GraphType3degE11vertex_type">
size_t <code class="descclassname">GraphType::</code><code class="descname">deg</code><span class="sig-paren">(</span>vertex_type <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPN9GraphType3degE11vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return the degree of the given node.</p>
<dl class="function">
<dt id="_CPPN9GraphType13adjanct_beginE11vertex_type">
iterator <code class="descclassname">GraphType::</code><code class="descname">adjanct_begin</code><span class="sig-paren">(</span>vertex_type <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPN9GraphType13adjanct_beginE11vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return an iterator to the start of the list of adjanct nodes of the input
node. The iterator can be of any kind (must support increment, deref and comparison).</p>
<dl class="function">
<dt id="_CPPN9GraphType11adjanct_endE11vertex_type">
iterator <code class="descclassname">GraphType::</code><code class="descname">adjanct_end</code><span class="sig-paren">(</span>vertex_type <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPN9GraphType11adjanct_endE11vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return an iterator to the end of the list of adjanct nodes of the input
node.</p>
<p>See <code class="docutils literal"><span class="pre">examples/community.cpp</span></code> for an example of use.</p>
</div>
<div class="section" id="time-dependent-personalized-pagerank">
<h3>Time-Dependent Personalized PageRank<a class="headerlink" href="#time-dependent-personalized-pagerank" title="Permalink to this headline">¶</a></h3>
<p>The community detection algorithm is based on a localized solution of
a Time-Dependent Personlized PageRank diffusion problem. See the
paper for details:</p>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">H. Avron and L. Horesh</div>
<div class="line">Community Detection Using Time-Dependent Personalized PageRank</div>
</div>
</li>
</ul>
</div></blockquote>
<p>The library also exposes the ability to solve the diffusion problem.
In this functionality, the input is a scalar function on nodes, and the
output is a vector function on nodes. Each entry of the vector
represents a different time point.</p>
<p>The interface is as follows:</p>
<dl class="function">
<dt id="_CPP16TimeDependentPPRRK9GraphTypeRKNSt13unordered_mapIN9GraphType11vertex_typeE1TEERNSt13unordered_mapIN9GraphType11vertex_typeEPN2El6MatrixI1TEEEERN2El6MatrixI1TEEdddi">
void <code class="descclassname"></code><code class="descname">TimeDependentPPR</code><span class="sig-paren">(</span><em class="property">const</em> GraphType &amp;<em>G</em>, <em class="property">const</em> std::unordered_map&lt;<em class="property">typename</em> GraphType::<a class="reference internal" href="#_CPPN9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>, T&gt; &amp;<em>s</em>, std::unordered_map&lt;<em class="property">typename</em> GraphType::<a class="reference internal" href="#_CPPN9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>, El::Matrix&lt;T&gt;*&gt; &amp;<em>y</em>, El::Matrix&lt;T&gt; &amp;<em>x</em>, double <em>alpha</em>, double <em>gamma</em>, double <em>epsilon</em>, int <em>NX</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPP16TimeDependentPPRRK9GraphTypeRKNSt13unordered_mapIN9GraphType11vertex_typeE1TEERNSt13unordered_mapIN9GraphType11vertex_typeEPN2El6MatrixI1TEEEERN2El6MatrixI1TEEdddi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>s is the input function of nodes, while y is the output. x specifies the time points which
corresponds to the entries of x[node]. alpha, gamma, epsilon and NX are
parameters of the algorithm. See paper for details. Defaults are specified.</p>
<p>The graph is specified using parameter G. The type is generic: the GraphType class is expected to
support the following:</p>
<dl class="type">
<dt>
<em class="property">type </em><code class="descclassname">GraphType::</code><code class="descname">vertex_type</code></dt>
<dd></dd></dl>

<p>Type of the graph nodes</p>
<dl class="function">
<dt>
size_t <code class="descclassname">GraphType::</code><code class="descname">num_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>Return the number of edges in the graph.</p>
<dl class="function">
<dt>
size_t <code class="descclassname">GraphType::</code><code class="descname">deg</code><span class="sig-paren">(</span>vertex_type <em>node</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>Return the degree of the given node.</p>
<dl class="function">
<dt>
iterator <code class="descclassname">GraphType::</code><code class="descname">adjanct_begin</code><span class="sig-paren">(</span>vertex_type <em>node</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>Return an iterator to the start of the list of adjanct nodes of the input
node. The iterator can be of any kind (must support increment, deref and comparison).</p>
<dl class="function">
<dt>
iterator <code class="descclassname">GraphType::</code><code class="descname">adjanct_end</code><span class="sig-paren">(</span>vertex_type <em>node</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>Return an iterator to the end of the list of adjanct nodes of the input
node.</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="nla.html">Numerical Linear Algebra Primitives</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="io.html">IO in libSkylark</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright IBM Corporation 2012-2014.  All Rights Reserved.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b1.
    </div>
  </body>
</html>