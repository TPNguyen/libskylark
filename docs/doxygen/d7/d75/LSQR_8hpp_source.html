<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Skylark (Sketching Library): /var/lib/jenkins/jobs/Skylark/workspace/algorithms/Krylov/LSQR.hpp Source File</title>

<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Skylark (Sketching Library)
   &#160;<span id="projectnumber">0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/var/lib/jenkins/jobs/Skylark/workspace/algorithms/Krylov/LSQR.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d7/d75/LSQR_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef SKYLARK_LSQR_HPP</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define SKYLARK_LSQR_HPP</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;../../base/base.hpp&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &quot;../../utility/elem_extender.hpp&quot;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &quot;../../utility/typer.hpp&quot;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &quot;../../utility/external/print.hpp&quot;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;<a class="code" href="../../d1/d10/precond_8hpp.html">precond.hpp</a>&quot;</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="keyword">namespace </span>skylark { <span class="keyword">namespace </span>nla {
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="comment">// We can have a version that is indpendent of Elemental. But that will</span>
<a name="l00013"></a>00013 <span class="comment">// be tedious (convert between [STAR,STAR] and vector&lt;T&gt;, and really</span>
<a name="l00014"></a>00014 <span class="comment">// elemental is a very fudmanetal to Skylark.</span>
<a name="l00015"></a>00015 <span class="preprocessor">#if SKYLARK_HAVE_ELEMENTAL</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> RhsType, <span class="keyword">typename</span> SolType&gt;
<a name="l00023"></a><a class="code" href="../../df/d91/namespaceskylark_1_1nla.html#abe3ce813e7ca15c08aac1b67ab21222e">00023</a> <span class="keywordtype">int</span> <a class="code" href="../../df/d91/namespaceskylark_1_1nla.html#abe3ce813e7ca15c08aac1b67ab21222e">LSQR</a>(<span class="keyword">const</span> <a class="code" href="../../d9/da8/elemental_8cpp.html#a8a80d5c50a127fe1d06bdab3e1dfbdc2">MatrixType</a>&amp; A, <span class="keyword">const</span> RhsType&amp; B, SolType&amp; X,
<a name="l00024"></a>00024     <a class="code" href="../../d8/d27/structskylark_1_1nla_1_1iter__params__t.html">iter_params_t</a> params = <a class="code" href="../../d8/d27/structskylark_1_1nla_1_1iter__params__t.html">iter_params_t</a>(),
<a name="l00025"></a>00025     <span class="keyword">const</span> <a class="code" href="../../d1/dc2/structskylark_1_1nla_1_1precond__t.html">precond_t&lt;SolType&gt;</a>&amp; R = <a class="code" href="../../dd/dac/structskylark_1_1nla_1_1id__precond__t.html">id_precond_t&lt;SolType&gt;</a>()) {
<a name="l00026"></a>00026 
<a name="l00027"></a>00027     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="../../d4/d11/structskylark_1_1utility_1_1typer__t.html#a75eaa6c10e55af07fbe940fceb611639">utility::typer_t&lt;MatrixType&gt;::value_type</a> value_t;
<a name="l00028"></a>00028     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="../../d4/d11/structskylark_1_1utility_1_1typer__t.html#ade88a1c34f1e2b57548a0087c6f2c8f0">utility::typer_t&lt;MatrixType&gt;::index_type</a> index_t;
<a name="l00029"></a>00029 
<a name="l00030"></a>00030     <span class="keyword">typedef</span> <a class="code" href="../../d9/da8/elemental_8cpp.html#a8a80d5c50a127fe1d06bdab3e1dfbdc2">MatrixType</a> <a class="code" href="../../d1/d6a/least__squares_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a>;
<a name="l00031"></a>00031     <span class="keyword">typedef</span> RhsType <a class="code" href="../../d1/d6a/least__squares_8cpp.html#a2fc464ae64ca81fffc2b0034a28790d4">rhs_type</a>;        <span class="comment">// Also serves as &quot;long&quot; vector type.</span>
<a name="l00032"></a>00032     <span class="keyword">typedef</span> SolType <a class="code" href="../../d1/d6a/least__squares_8cpp.html#a0ccbceff43e70b9bf68fc4b0d4a07e49">sol_type</a>;        <span class="comment">// Also serves as &quot;short&quot; vector type.</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034     <span class="keyword">typedef</span> <a class="code" href="../../d5/da3/structskylark_1_1utility_1_1print__t.html">utility::print_t&lt;rhs_type&gt;</a> rhs_print_t;
<a name="l00035"></a>00035     <span class="keyword">typedef</span> <a class="code" href="../../d5/da3/structskylark_1_1utility_1_1print__t.html">utility::print_t&lt;sol_type&gt;</a> sol_print_t;
<a name="l00036"></a>00036 
<a name="l00037"></a>00037     <span class="keyword">typedef</span> utility::elem_extender_t&lt;
<a name="l00038"></a>00038         elem::DistMatrix&lt;value_t, elem::STAR, elem::STAR&gt; &gt;
<a name="l00039"></a>00039         scalar_cont_type;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041     <span class="keywordtype">bool</span> log_lev1 = params.am_i_printing &amp;&amp; params.log_level &gt;= 1;
<a name="l00042"></a>00042     <span class="keywordtype">bool</span> log_lev2 = params.am_i_printing &amp;&amp; params.log_level &gt;= 2;
<a name="l00043"></a>00043 
<a name="l00045"></a>00045     index_t <a class="code" href="../../d1/d6a/least__squares_8cpp.html#a0d2d8836216fc94b61aa0824eb239db2">m</a> = <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a8765cb27091c3ce9e4c3b476b78a5d22">base::Height</a>(A);
<a name="l00046"></a>00046     index_t <a class="code" href="../../d1/d6a/least__squares_8cpp.html#acfc02ec89670db29251fda6a66602ce2">n</a> = <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#afbb35d81fb98da3e9c6b519101ba9d2d">base::Width</a>(A);
<a name="l00047"></a>00047     index_t k = <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#afbb35d81fb98da3e9c6b519101ba9d2d">base::Width</a>(B);
<a name="l00048"></a>00048 
<a name="l00050"></a>00050     <span class="keyword">const</span> value_t eps = 32*std::numeric_limits&lt;value_t&gt;::epsilon();
<a name="l00051"></a>00051     <span class="keywordflow">if</span> (params.tolerance&lt;eps) params.tolerance=eps;
<a name="l00052"></a>00052     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (params.tolerance&gt;=1.0) params.tolerance=(1-eps);
<a name="l00053"></a>00053     <span class="keywordflow">else</span> {} <span class="comment">/* nothing */</span>
<a name="l00054"></a>00054 
<a name="l00056"></a>00056     <span class="comment">// We set the grid and rank for beta, and all other scalar containers</span>
<a name="l00057"></a>00057     <span class="comment">// just copy from him to get that to be set right (not for the values).</span>
<a name="l00058"></a>00058     rhs_type U(B);
<a name="l00059"></a>00059     scalar_cont_type beta(k, 1, A.Grid(), A.Root()), i_beta(beta);
<a name="l00060"></a>00060     base::ColumnNrm2(U, beta);
<a name="l00061"></a>00061     <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i)
<a name="l00062"></a>00062         i_beta[i] = 1 / beta[i];
<a name="l00063"></a>00063     base::DiagonalScale(elem::RIGHT, elem::NORMAL, i_beta, U);
<a name="l00064"></a>00064     rhs_print_t::apply(U, <span class="stringliteral">&quot;U Init&quot;</span>, params.am_i_printing, params.debug_level);
<a name="l00065"></a>00065 
<a name="l00066"></a>00066     sol_type V(X);     <span class="comment">// No need to really copy, just want sizes&amp;comm correct.</span>
<a name="l00067"></a>00067     <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a8f7ed6aa7741ff54e546fa88fc706a53">base::Gemm</a>(elem::ADJOINT, elem::NORMAL, 1.0, A, U, V);
<a name="l00068"></a>00068     R.apply_adjoint(V);
<a name="l00069"></a>00069     scalar_cont_type alpha(beta), i_alpha(beta);
<a name="l00070"></a>00070     base::ColumnNrm2(V, alpha);
<a name="l00071"></a>00071     <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i)
<a name="l00072"></a>00072         i_alpha[i] = 1 / alpha[i];
<a name="l00073"></a>00073     base::DiagonalScale(elem::RIGHT, elem::NORMAL, i_alpha, V);
<a name="l00074"></a>00074     sol_type Z(V);
<a name="l00075"></a>00075     R.apply(Z);
<a name="l00076"></a>00076     sol_print_t::apply(V, <span class="stringliteral">&quot;V Init&quot;</span>, params.am_i_printing, params.debug_level);
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     <span class="comment">/* Create W=Z and X=0 */</span>
<a name="l00079"></a>00079     base::Zero(X);
<a name="l00080"></a>00080     sol_type W(Z);
<a name="l00081"></a>00081     scalar_cont_type phibar(beta), rhobar(alpha), nrm_r(beta);
<a name="l00082"></a>00082         <span class="comment">// /!\ Actually copied for init</span>
<a name="l00083"></a>00083     scalar_cont_type nrm_a(beta), cnd_a(beta), sq_d(beta), nrm_ar_0(beta);
<a name="l00084"></a>00084     base::Zero(nrm_a); base::Zero(cnd_a); base::Zero(sq_d);
<a name="l00085"></a>00085     elem::Hadamard(alpha, beta, nrm_ar_0);
<a name="l00086"></a>00086 
<a name="l00088"></a>00088     <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i)
<a name="l00089"></a>00089         <span class="keywordflow">if</span> (nrm_ar_0[i]==0)
<a name="l00090"></a>00090             <span class="keywordflow">return</span> 0;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     scalar_cont_type nrm_x(beta), sq_x(beta), z(beta), cs2(beta), sn2(beta);
<a name="l00093"></a>00093     elem::Zero(nrm_x); elem::Zero(sq_x); elem::Zero(z); elem::Zero(sn2);
<a name="l00094"></a>00094     <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i)
<a name="l00095"></a>00095         cs2[i] = -1.0;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     <span class="keywordtype">int</span> max_n_stag = 3;
<a name="l00098"></a>00098     std::vector&lt;int&gt; stag(k, 0);
<a name="l00099"></a>00099 
<a name="l00100"></a>00100     <span class="comment">/* Reset the iteration limit if none was specified */</span>
<a name="l00101"></a>00101     <span class="keywordflow">if</span> (0&gt;params.iter_lim) params.iter_lim = <a class="code" href="../../df/d93/utils_8hpp.html#a5b8922aac97383a6bdcf7fd777f6ea85">std::max</a>(20, 2*<a class="code" href="../../df/d93/utils_8hpp.html#a3f9599c9c447625449f078e770cf9f37">std::min</a>(m,n));
<a name="l00102"></a>00102 
<a name="l00103"></a>00103     <span class="comment">/* More varaibles */</span>
<a name="l00104"></a>00104     sol_type AU(X);
<a name="l00105"></a>00105     scalar_cont_type minus_beta(beta), rho(beta);
<a name="l00106"></a>00106     scalar_cont_type cs(beta), sn(beta), theta(beta), phi(beta);
<a name="l00107"></a>00107     scalar_cont_type phi_by_rho(beta), minus_theta_by_rho(beta), nrm_ar(beta);
<a name="l00108"></a>00108     scalar_cont_type nrm_w(beta), sq_w(beta), gamma(beta);
<a name="l00109"></a>00109     scalar_cont_type delta(beta), gambar(beta), rhs(beta), zbar(beta);
<a name="l00110"></a>00110 
<a name="l00112"></a>00112     <span class="keywordflow">for</span> (index_t itn=0; itn&lt;params.iter_lim; ++itn) {
<a name="l00113"></a>00113 
<a name="l00115"></a>00115         elem::Scal(-1.0, alpha);   <span class="comment">// Can safely overwrite based on subseq ops.</span>
<a name="l00116"></a>00116         base::DiagonalScale(elem::RIGHT, elem::NORMAL, alpha, U);
<a name="l00117"></a>00117         <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a8f7ed6aa7741ff54e546fa88fc706a53">base::Gemm</a>(elem::NORMAL, elem::NORMAL, 1.0, A, Z, 1.0, U);
<a name="l00118"></a>00118         base::ColumnNrm2(U, beta);
<a name="l00119"></a>00119         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i)
<a name="l00120"></a>00120             i_beta[i] = 1 / beta[i];
<a name="l00121"></a>00121         base::DiagonalScale(elem::RIGHT, elem::NORMAL, i_beta, U);
<a name="l00122"></a>00122 
<a name="l00124"></a>00124         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i) {
<a name="l00125"></a>00125             <span class="keywordtype">double</span> a = nrm_a[i], b = alpha[i], c = beta[i];
<a name="l00126"></a>00126             nrm_a[i] = sqrt(a*a + b*b + c*c);
<a name="l00127"></a>00127         }
<a name="l00128"></a>00128 
<a name="l00130"></a>00130         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i)
<a name="l00131"></a>00131             minus_beta[i] = -beta[i];
<a name="l00132"></a>00132         base::DiagonalScale(elem::RIGHT, elem::NORMAL, minus_beta, V);
<a name="l00133"></a>00133         <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a8f7ed6aa7741ff54e546fa88fc706a53">base::Gemm</a>(elem::ADJOINT, elem::NORMAL, 1.0, A, U, AU);
<a name="l00134"></a>00134         R.apply_adjoint(AU);
<a name="l00135"></a>00135         base::Axpy(1.0, AU, V);
<a name="l00136"></a>00136         base::ColumnNrm2(V, alpha);
<a name="l00137"></a>00137         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i)
<a name="l00138"></a>00138             i_alpha[i] = 1 / alpha[i];
<a name="l00139"></a>00139         base::DiagonalScale(elem::RIGHT, elem::NORMAL, i_alpha, V);
<a name="l00140"></a>00140         Z = V; R.apply(Z);
<a name="l00141"></a>00141 
<a name="l00143"></a>00143         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i) {
<a name="l00144"></a>00144             rho[i] = sqrt((rhobar[i]*rhobar[i]) + (beta[i]*beta[i]));
<a name="l00145"></a>00145             cs[i] = rhobar[i]/rho[i];
<a name="l00146"></a>00146             sn[i] =  beta[i]/rho[i];  
<a name="l00147"></a>00147             theta[i] = sn[i]*alpha[i];
<a name="l00148"></a>00148             rhobar[i] = -cs[i]*alpha[i];
<a name="l00149"></a>00149             phi[i] = cs[i]*phibar[i];
<a name="l00150"></a>00150             phibar[i] =  sn[i]*phibar[i];
<a name="l00151"></a>00151         }
<a name="l00152"></a>00152 
<a name="l00154"></a>00154         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i)
<a name="l00155"></a>00155             phi_by_rho[i] = phi[i]/rho[i];
<a name="l00156"></a>00156         base::Axpy(phi_by_rho, W, X);
<a name="l00157"></a>00157         sol_print_t::apply(X, <span class="stringliteral">&quot;X&quot;</span>, params.am_i_printing, params.debug_level);
<a name="l00158"></a>00158 
<a name="l00159"></a>00159         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i)
<a name="l00160"></a>00160             minus_theta_by_rho[i] = -theta[i]/rho[i];
<a name="l00161"></a>00161         base::DiagonalScale(elem::RIGHT, elem::NORMAL, minus_theta_by_rho, W);
<a name="l00162"></a>00162         base::Axpy(1.0, Z, W);
<a name="l00163"></a>00163         sol_print_t::apply(W, <span class="stringliteral">&quot;W&quot;</span>, params.am_i_printing, params.debug_level);
<a name="l00164"></a>00164 
<a name="l00166"></a>00166         nrm_r = phibar;
<a name="l00167"></a>00167 
<a name="l00169"></a>00169         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i) {
<a name="l00170"></a>00170             nrm_ar[i] = std::abs(phibar[i]*alpha[i]*cs[i]);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172             <span class="keywordflow">if</span> (log_lev2)
<a name="l00173"></a>00173                 params.log_stream &lt;&lt; <span class="stringliteral">&quot;LSQR: Iteration &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; itn 
<a name="l00174"></a>00174                                   &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; nrm_ar[i]
<a name="l00175"></a>00175                                   &lt;&lt; std::endl;
<a name="l00176"></a>00176 
<a name="l00178"></a>00178             <span class="keywordflow">if</span> (nrm_ar[i]&lt;(params.tolerance*nrm_ar_0[i])) {
<a name="l00179"></a>00179                 <span class="keywordflow">if</span> (log_lev1)
<a name="l00180"></a>00180                     params.log_stream &lt;&lt; <span class="stringliteral">&quot;LSQR: Convergence (S1)!&quot;</span> &lt;&lt; std::endl;
<a name="l00181"></a>00181                 <span class="keywordflow">return</span> -2;
<a name="l00182"></a>00182             }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184             <span class="keywordflow">if</span> (nrm_ar[i]&lt;(eps*nrm_a[i]*nrm_r[i])) {
<a name="l00185"></a>00185                 <span class="keywordflow">if</span> (log_lev1)
<a name="l00186"></a>00186                     params.log_stream &lt;&lt; <span class="stringliteral">&quot;LSQR: Convergence (S2)!&quot;</span> &lt;&lt; std::endl;
<a name="l00187"></a>00187                 <span class="keywordflow">return</span> -3;
<a name="l00188"></a>00188             }
<a name="l00189"></a>00189         }
<a name="l00190"></a>00190 
<a name="l00192"></a>00192         base::ColumnNrm2(W, nrm_w);
<a name="l00193"></a>00193         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i) {
<a name="l00194"></a>00194             sq_w[i] = nrm_w[i]*nrm_w[i];
<a name="l00195"></a>00195             sq_d[i] += sq_w[i]/(rho[i]*rho[i]);
<a name="l00196"></a>00196             cnd_a[i] = nrm_a[i]*sqrt(sq_d[i]);
<a name="l00197"></a>00197 
<a name="l00199"></a>00199             <span class="keywordflow">if</span> (cnd_a[i]&gt;(1.0/eps)) {
<a name="l00200"></a>00200                 <span class="keywordflow">if</span> (log_lev1)
<a name="l00201"></a>00201                     params.log_stream &lt;&lt; <span class="stringliteral">&quot;LSQR: Stopping (S3)!&quot;</span> &lt;&lt; std::endl;
<a name="l00202"></a>00202                 <span class="keywordflow">return</span> -4;
<a name="l00203"></a>00203             }
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205 
<a name="l00207"></a>00207         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i) {
<a name="l00208"></a>00208             <span class="keywordflow">if</span> (std::abs(phi[i]/rho[i])*nrm_w[i] &lt; (eps*nrm_x[i]))
<a name="l00209"></a>00209                 stag[i]++;
<a name="l00210"></a>00210             <span class="keywordflow">else</span>
<a name="l00211"></a>00211                 stag[i] = 0;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213             <span class="keywordflow">if</span> (stag[i] &gt;= max_n_stag) {
<a name="l00214"></a>00214                 <span class="keywordflow">if</span> (log_lev1)
<a name="l00215"></a>00215                     params.log_stream &lt;&lt; <span class="stringliteral">&quot;LSQR: Stagnation.&quot;</span> &lt;&lt; std::endl;
<a name="l00216"></a>00216                 <span class="keywordflow">return</span> -5;
<a name="l00217"></a>00217             }
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219 
<a name="l00221"></a>00221         <span class="keywordflow">for</span> (index_t i=0; i&lt;k; ++i) {
<a name="l00222"></a>00222             delta[i] =  sn2[i]*rho[i];
<a name="l00223"></a>00223             gambar[i] = -cs2[i]*rho[i];
<a name="l00224"></a>00224             rhs[i] = phi[i] - delta[i]*z[i];
<a name="l00225"></a>00225             zbar[i] = rhs[i]/gambar[i];
<a name="l00226"></a>00226             nrm_x[i] = sqrt(sq_x[i] + (zbar[i]*zbar[i]));
<a name="l00227"></a>00227             gamma[i] = sqrt((gambar[i]*gambar[i]) + (theta[i]*theta[i]));
<a name="l00228"></a>00228             cs2[i] = gambar[i]/gamma[i];
<a name="l00229"></a>00229             sn2[i] = theta[i]/gamma[i];
<a name="l00230"></a>00230             z[i] = rhs[i]/gamma[i];
<a name="l00231"></a>00231             sq_x[i] += z[i]*z[i];
<a name="l00232"></a>00232         }
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234     <span class="keywordflow">if</span> (log_lev1)
<a name="l00235"></a>00235         params.log_stream &lt;&lt; <span class="stringliteral">&quot;LSQR: No convergence within iteration limit.&quot;</span>
<a name="l00236"></a>00236                           &lt;&lt; std::endl;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     <span class="keywordflow">return</span> -6;
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="preprocessor">#endif</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span>
<a name="l00243"></a>00243 } } 
<a name="l00245"></a>00245 <span class="preprocessor">#endif // SKYLARK_LSQR_HPP</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 18:16:07 for Skylark (Sketching Library) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
