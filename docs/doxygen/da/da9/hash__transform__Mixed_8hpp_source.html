<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Skylark (Sketching Library): /var/lib/jenkins/jobs/Skylark/workspace/sketch/hash_transform_Mixed.hpp Source File</title>

<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Skylark (Sketching Library)
   &#160;<span id="projectnumber">0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/var/lib/jenkins/jobs/Skylark/workspace/sketch/hash_transform_Mixed.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../da/da9/hash__transform__Mixed_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef SKYLARK_HASH_TRANSFORM_MIXED_HPP</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define SKYLARK_HASH_TRANSFORM_MIXED_HPP</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;boost/serialization/map.hpp&gt;</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#include &quot;../utility/external/combblas_comm_grid.hpp&quot;</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="keyword">namespace </span>skylark { <span class="keyword">namespace </span>sketch {
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment">//FIXME:</span>
<a name="l00012"></a>00012 <span class="comment">//  - Benchmark one-sided vs. col/row comm (or midpoint scheme):</span>
<a name="l00013"></a>00013 <span class="comment">//    Most likely the scheme depends on the output Elemental distribution,</span>
<a name="l00014"></a>00014 <span class="comment">//    here we use the same comm-scheme for all output types.</span>
<a name="l00015"></a>00015 <span class="comment">//  - Processing Sparse matrix in blocks?</span>
<a name="l00016"></a>00016 <span class="comment">//  - MPI-3 stuff, see: Enabling highly-scalable remote memory access</span>
<a name="l00017"></a>00017 <span class="comment">//    programming with MPI-3 one sided, R. Gerstenbergerm,  M. Besta, and</span>
<a name="l00018"></a>00018 <span class="comment">//    T. Hoefler.</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="comment">/* Specialization: SpParMat for input, distributed Elemental for output */</span>
<a name="l00022"></a>00022 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> IndexType,
<a name="l00023"></a>00023           <span class="keyword">typename</span> ValueType,
<a name="l00024"></a>00024           elem::Distribution ColDist,
<a name="l00025"></a>00025           elem::Distribution RowDist,
<a name="l00026"></a>00026           <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>IdxDistributionType,
<a name="l00027"></a>00027           <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>ValueDistribution&gt;
<a name="l00028"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html">00028</a> <span class="keyword">struct </span><a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html">hash_transform_t</a> &lt;
<a name="l00029"></a>00029     SpParMat&lt;IndexType, ValueType, SpDCCols&lt;IndexType, ValueType&gt; &gt;,
<a name="l00030"></a>00030     elem::<a class="code" href="../../dc/d74/capi_8cpp.html#a19350ba69c004b01dece9951a3477dc9">DistMatrix</a>&lt;ValueType, ColDist, RowDist&gt;,
<a name="l00031"></a>00031     IdxDistributionType,
<a name="l00032"></a>00032     ValueDistribution &gt; :
<a name="l00033"></a>00033         <span class="keyword">public</span> <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">hash_transform_data_t</a>&lt;IdxDistributionType,
<a name="l00034"></a>00034                                      ValueDistribution&gt; {
<a name="l00035"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a6959b6e391c4ebc42a9c8df52d33ebac">00035</a>     <span class="keyword">typedef</span> IndexType <a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a6959b6e391c4ebc42a9c8df52d33ebac">index_type</a>;
<a name="l00036"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a166a68d08e3a05363d773bc218bc05bd">00036</a>     <span class="keyword">typedef</span> ValueType <a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a166a68d08e3a05363d773bc218bc05bd">value_type</a>;
<a name="l00037"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a40181db7c816c920fde3a9db552d769b">00037</a>     <span class="keyword">typedef</span> SpDCCols&lt; index_type, value_type &gt; <a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a40181db7c816c920fde3a9db552d769b">col_t</a>;
<a name="l00038"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a4032e337a4f1ef90576ecfa8901214d5">00038</a>     <span class="keyword">typedef</span> FullyDistVec&lt; index_type, value_type&gt; <a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a4032e337a4f1ef90576ecfa8901214d5">mpi_vector_t</a>;
<a name="l00039"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a582bc851686fa76e11509ac89d4d550f">00039</a>     <span class="keyword">typedef</span> SpParMat&lt; index_type, value_type, col_t &gt; <a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a582bc851686fa76e11509ac89d4d550f">matrix_type</a>;
<a name="l00040"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#aea8da82292fa5d2c618b030defb9f894">00040</a>     <span class="keyword">typedef</span> elem::DistMatrix&lt; value_type, ColDist, RowDist &gt; <a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#aea8da82292fa5d2c618b030defb9f894">output_matrix_type</a>;
<a name="l00041"></a>00041     <span class="keyword">typedef</span> <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">hash_transform_data_t</a>&lt;IdxDistributionType,
<a name="l00042"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a178caf20400a6775d4600d9c69d344cc">00042</a>                                   ValueDistribution&gt; <a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a178caf20400a6775d4600d9c69d344cc">data_type</a>;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 
<a name="l00048"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a604606000dd61024cf62fb8a4f2ca969">00048</a>     <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a170fc8a64798cd59452b2a703348143e">hash_transform_t</a> (<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> S, <a class="code" href="../../de/dea/structskylark_1_1base_1_1context__t.html">base::context_t</a>&amp; context) :
<a name="l00049"></a>00049         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">data_type</a>(N, S, context) {
<a name="l00050"></a>00050 
<a name="l00051"></a>00051     }
<a name="l00052"></a>00052 
<a name="l00056"></a>00056     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputMatrixType,
<a name="l00057"></a>00057               <span class="keyword">typename</span> OutputMatrixType&gt;
<a name="l00058"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#ab1a9a3e7744ae89361ce526e134989ff">00058</a>     <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a170fc8a64798cd59452b2a703348143e">hash_transform_t</a> (<a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html">hash_transform_t</a>&lt;InputMatrixType,
<a name="l00059"></a>00059                                        OutputMatrixType,
<a name="l00060"></a>00060                                        IdxDistributionType,
<a name="l00061"></a>00061                                        ValueDistribution&gt;&amp; other) :
<a name="l00062"></a>00062         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">data_type</a>(other) {}
<a name="l00063"></a>00063 
<a name="l00067"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a1a6a810199e5ecc51a1f60bff937e67e">00067</a>     <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a170fc8a64798cd59452b2a703348143e">hash_transform_t</a> (<a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">hash_transform_data_t</a>&lt;IdxDistributionType,
<a name="l00068"></a>00068                                             ValueDistribution&gt;&amp; other_data) :
<a name="l00069"></a>00069         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">data_type</a>(other_data) {}
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dimension&gt;
<a name="l00072"></a><a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a5fa096f9a2aa5c5bd2523b5611d1f37d">00072</a>     <span class="keywordtype">void</span> <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#ac899bcbff87aa859ada4b0e2f7705205">apply</a> (<span class="keyword">const</span> <a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#a582bc851686fa76e11509ac89d4d550f">matrix_type</a> &amp;A, <a class="code" href="../../d7/d33/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpDd9a6ac0cd2bfb9e9e46ee3992fe79438.html#aea8da82292fa5d2c618b030defb9f894">output_matrix_type</a> &amp;sketch_of_A,
<a name="l00073"></a>00073                 Dimension dimension)<span class="keyword"> const </span>{
<a name="l00074"></a>00074         <span class="keywordflow">try</span> {
<a name="l00075"></a>00075             apply_impl (A, sketch_of_A, dimension);
<a name="l00076"></a>00076         } <span class="keywordflow">catch</span>(boost::mpi::exception e) {
<a name="l00077"></a>00077             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00078"></a>00078                 <a class="code" href="../../dc/d20/structskylark_1_1base_1_1mpi__exception.html" title="exceptions thrown by Boost MPI">base::mpi_exception</a>()
<a name="l00079"></a>00079                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(e.what()) );
<a name="l00080"></a>00080         } <span class="keywordflow">catch</span> (std::string e) {
<a name="l00081"></a>00081             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00082"></a>00082                 <a class="code" href="../../de/dbd/structskylark_1_1base_1_1combblas__exception.html" title="exceptions thrown by CombBLAS">base::combblas_exception</a>()
<a name="l00083"></a>00083                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(e) );
<a name="l00084"></a>00084         } <span class="keywordflow">catch</span> (std::logic_error e) {
<a name="l00085"></a>00085             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00086"></a>00086                 <a class="code" href="../../de/dbd/structskylark_1_1base_1_1combblas__exception.html" title="exceptions thrown by CombBLAS">base::combblas_exception</a>()
<a name="l00087"></a>00087                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(e.what()) );
<a name="l00088"></a>00088         } <span class="keywordflow">catch</span> (std::bad_alloc e) {
<a name="l00089"></a>00089             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00090"></a>00090                 <a class="code" href="../../d4/d8e/structskylark_1_1base_1_1skylark__exception.html" title="define a base exception">base::skylark_exception</a>()
<a name="l00091"></a>00091                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(<span class="stringliteral">&quot;bad_alloc: out of memory&quot;</span>) );
<a name="l00092"></a>00092         }
<a name="l00093"></a>00093     }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="keyword">private</span>:
<a name="l00100"></a>00100     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dimension&gt;
<a name="l00101"></a>00101     <span class="keywordtype">void</span> apply_impl (<span class="keyword">const</span> <a class="code" href="../../d8/d1e/regression_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a> &amp;A_,
<a name="l00102"></a>00102         <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a4d90fe83e2669e836dacfa17e1b29213">output_matrix_type</a> &amp;sketch_of_A,
<a name="l00103"></a>00103         Dimension dist)<span class="keyword"> const </span>{
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         <span class="comment">// We are essentially doing a &#39;const&#39; access to A, but the necessary,</span>
<a name="l00106"></a>00106         <span class="comment">// &#39;const&#39; option is missing from the interface</span>
<a name="l00107"></a>00107         <a class="code" href="../../d8/d1e/regression_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a> &amp;A = <span class="keyword">const_cast&lt;</span><a class="code" href="../../d8/d1e/regression_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a>&amp;<span class="keyword">&gt;</span>(A_);
<a name="l00108"></a>00108 
<a name="l00109"></a>00109         <span class="keyword">const</span> <span class="keywordtype">size_t</span> rank = A.getcommgrid()-&gt;GetRank();
<a name="l00110"></a>00110 
<a name="l00111"></a>00111         <span class="comment">// extract columns of matrix</span>
<a name="l00112"></a>00112         <a class="code" href="../../dc/d74/capi_8cpp.html#ac21a17a4a9d7c56130fbacaeaf5b44c8">col_t</a> &amp;data = A.seq();
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         <span class="keyword">const</span> <span class="keywordtype">size_t</span> ncols = sketch_of_A.Width();
<a name="l00115"></a>00115 
<a name="l00116"></a>00116         <span class="keyword">const</span> <span class="keywordtype">size_t</span> my_row_offset = utility::cb_my_row_offset(A);
<a name="l00117"></a>00117         <span class="keyword">const</span> <span class="keywordtype">size_t</span> my_col_offset = utility::cb_my_col_offset(A);
<a name="l00118"></a>00118 
<a name="l00119"></a>00119         <span class="keywordtype">size_t</span> comm_size = A.getcommgrid()-&gt;GetSize();
<a name="l00120"></a>00120         std::vector&lt; std::set&lt;size_t&gt; &gt; proc_set(comm_size);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         <span class="comment">// pre-compute processor targets of local sketch application</span>
<a name="l00123"></a>00123         <span class="keywordflow">for</span>(<span class="keyword">typename</span> col_t::SpColIter col = data.begcol();
<a name="l00124"></a>00124             col != data.endcol(); col++) {
<a name="l00125"></a>00125             <span class="keywordflow">for</span>(<span class="keyword">typename</span> col_t::SpColIter::NzIter nz = data.begnz(col);
<a name="l00126"></a>00126                 nz != data.endnz(col); nz++) {
<a name="l00127"></a>00127 
<a name="l00128"></a>00128                 <span class="comment">// compute global row and column id, and compress in one</span>
<a name="l00129"></a>00129                 <span class="comment">// target position index</span>
<a name="l00130"></a>00130                 <span class="keyword">const</span> index_type rowid = nz.rowid()  + my_row_offset;
<a name="l00131"></a>00131                 <span class="keyword">const</span> index_type colid = col.colid() + my_col_offset;
<a name="l00132"></a>00132                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> pos       = getPos(rowid, colid, ncols, dist);
<a name="l00133"></a>00133 
<a name="l00134"></a>00134                 <span class="comment">// compute target processor for this target index</span>
<a name="l00135"></a>00135                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> target =
<a name="l00136"></a>00136                     sketch_of_A.Owner(pos / ncols, pos % ncols);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138                 <span class="keywordflow">if</span>(proc_set[target].count(pos) == 0) {
<a name="l00139"></a>00139                     assert(target &lt; comm_size);
<a name="l00140"></a>00140                     proc_set[target].insert(pos);
<a name="l00141"></a>00141                 }
<a name="l00142"></a>00142             }
<a name="l00143"></a>00143         }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         <span class="comment">// constructing array holding start/end indices for one-sided access</span>
<a name="l00146"></a>00146         std::vector&lt;index_type&gt; proc_start_idx(comm_size + 1, 0);
<a name="l00147"></a>00147         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 1; i &lt; comm_size + 1; ++i)
<a name="l00148"></a>00148             proc_start_idx[i] = proc_start_idx[i-1] + proc_set[i-1].size();
<a name="l00149"></a>00149 
<a name="l00150"></a>00150         <span class="comment">// total number of nnz that will result when applying sketch locally</span>
<a name="l00151"></a>00151         std::vector&lt;index_type&gt; indicies(proc_start_idx[comm_size], 0);
<a name="l00152"></a>00152         std::vector&lt;value_type&gt; values(proc_start_idx[comm_size], 0);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         <span class="comment">// Apply sketch for all local values. Note that some of the resulting</span>
<a name="l00155"></a>00155         <span class="comment">// values might end up on a different processor. The data structure</span>
<a name="l00156"></a>00156         <span class="comment">// fills values (sorted by processor id) in one continuous array.</span>
<a name="l00157"></a>00157         <span class="comment">// Subsequently, one-sided operations can be used to access values for</span>
<a name="l00158"></a>00158         <span class="comment">// each processor.</span>
<a name="l00159"></a>00159         <span class="keywordflow">for</span>(<span class="keyword">typename</span> col_t::SpColIter col = data.begcol();
<a name="l00160"></a>00160             col != data.endcol(); col++) {
<a name="l00161"></a>00161             <span class="keywordflow">for</span>(<span class="keyword">typename</span> col_t::SpColIter::NzIter nz = data.begnz(col);
<a name="l00162"></a>00162                 nz != data.endnz(col); nz++) {
<a name="l00163"></a>00163 
<a name="l00164"></a>00164                 <span class="comment">// compute global row and column id, and compress in one</span>
<a name="l00165"></a>00165                 <span class="comment">// target position index</span>
<a name="l00166"></a>00166                 <span class="keyword">const</span> index_type rowid = nz.rowid()  + my_row_offset;
<a name="l00167"></a>00167                 <span class="keyword">const</span> index_type colid = col.colid() + my_col_offset;
<a name="l00168"></a>00168                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> pos       = getPos(rowid, colid, ncols, dist);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170                 <span class="comment">// compute target processor for this target index</span>
<a name="l00171"></a>00171                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> proc = sketch_of_A.Owner(pos / ncols, pos % ncols);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173                 <span class="comment">// get offset in array for current element</span>
<a name="l00174"></a>00174                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> ar_idx = proc_start_idx[proc] +
<a name="l00175"></a>00175                     std::distance(proc_set[proc].begin(), proc_set[proc].find(pos));
<a name="l00176"></a>00176 
<a name="l00177"></a>00177                 indicies[ar_idx] = pos;
<a name="l00178"></a>00178                 values[ar_idx]  += nz.value() *
<a name="l00179"></a>00179                                    <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html#a67da8cff5cfd14ff5b993f5c4b33e9dc">data_type::getValue</a>(rowid, colid, dist);
<a name="l00180"></a>00180             }
<a name="l00181"></a>00181         }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183         <span class="comment">// Creating windows for all relevant arrays</span>
<a name="l00184"></a>00184         boost::mpi::communicator comm = <a class="code" href="../../db/d39/namespaceskylark_1_1utility.html#a603e0fe4127da3887ceed891a58b3d38">utility::get_communicator</a>(A);
<a name="l00185"></a>00185 
<a name="l00186"></a>00186         <span class="comment">// tell MPI that we will not use locks</span>
<a name="l00187"></a>00187         MPI_Info info;
<a name="l00188"></a>00188         MPI_Info_create(&amp;info);
<a name="l00189"></a>00189         MPI_Info_set(info, <span class="stringliteral">&quot;no_locks&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         MPI_Win start_offset_win, idx_win, val_win;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         MPI_Win_create(&amp;proc_start_idx[0], <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>) * (comm_size + 1),
<a name="l00194"></a>00194                        <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), info, comm, &amp;start_offset_win);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         MPI_Win_create(&amp;indicies[0], <span class="keyword">sizeof</span>(index_type) * indicies.size(),
<a name="l00197"></a>00197                        <span class="keyword">sizeof</span>(index_type), info, comm, &amp;idx_win);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         MPI_Win_create(&amp;values[0], <span class="keyword">sizeof</span>(value_type) * values.size(),
<a name="l00200"></a>00200                        <span class="keyword">sizeof</span>(value_type), info, comm, &amp;val_win);
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         MPI_Info_free(&amp;info);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         <span class="comment">// Synchronize epoch, no subsequent put operations (read only) and no</span>
<a name="l00205"></a>00205         <span class="comment">// preceding fence calls.</span>
<a name="l00206"></a>00206         MPI_Win_fence(MPI_MODE_NOPUT | MPI_MODE_NOPRECEDE, start_offset_win);
<a name="l00207"></a>00207         MPI_Win_fence(MPI_MODE_NOPUT | MPI_MODE_NOPRECEDE, idx_win);
<a name="l00208"></a>00208         MPI_Win_fence(MPI_MODE_NOPUT | MPI_MODE_NOPRECEDE, val_win);
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         <span class="comment">// accumulate values from other procs</span>
<a name="l00212"></a>00212         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> p = 0; p &lt; comm_size; ++p) {
<a name="l00213"></a>00213 
<a name="l00214"></a>00214             <span class="comment">// get the start/end offset</span>
<a name="l00215"></a>00215             std::vector&lt;size_t&gt; offset(2);
<a name="l00216"></a>00216             MPI_Get(&amp;(offset[0]), 2, boost::mpi::get_mpi_datatype&lt;size_t&gt;(),
<a name="l00217"></a>00217                     p, rank, 2, boost::mpi::get_mpi_datatype&lt;size_t&gt;(),
<a name="l00218"></a>00218                     start_offset_win);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220             MPI_Win_fence(MPI_MODE_NOPUT, start_offset_win);
<a name="l00221"></a>00221             <span class="keywordtype">size_t</span> num_values = offset[1] - offset[0];
<a name="l00222"></a>00222 
<a name="l00223"></a>00223             <span class="comment">// and fill indices/values.</span>
<a name="l00224"></a>00224             std::vector&lt;index_type&gt; add_idx(num_values);
<a name="l00225"></a>00225             std::vector&lt;value_type&gt; add_val(num_values);
<a name="l00226"></a>00226             MPI_Get(&amp;(add_idx[0]), num_values,
<a name="l00227"></a>00227                     boost::mpi::get_mpi_datatype&lt;index_type&gt;(), p, offset[0],
<a name="l00228"></a>00228                     num_values, boost::mpi::get_mpi_datatype&lt;index_type&gt;(),
<a name="l00229"></a>00229                     idx_win);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231             MPI_Get(&amp;(add_val[0]), num_values,
<a name="l00232"></a>00232                     boost::mpi::get_mpi_datatype&lt;value_type&gt;(), p, offset[0],
<a name="l00233"></a>00233                     num_values, boost::mpi::get_mpi_datatype&lt;value_type&gt;(),
<a name="l00234"></a>00234                     val_win);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236             MPI_Win_fence(MPI_MODE_NOPUT, idx_win);
<a name="l00237"></a>00237             MPI_Win_fence(MPI_MODE_NOPUT, val_win);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239             <span class="comment">// finally, set data in local buffer</span>
<a name="l00240"></a>00240             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; num_values; ++i) {
<a name="l00241"></a>00241                 index_type lrow = sketch_of_A.LocalRow(add_idx[i] / ncols);
<a name="l00242"></a>00242                 index_type lcol = sketch_of_A.LocalCol(add_idx[i] % ncols);
<a name="l00243"></a>00243                 sketch_of_A.UpdateLocal(lrow, lcol, add_val[i]);
<a name="l00244"></a>00244             }
<a name="l00245"></a>00245         }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         MPI_Win_fence(MPI_MODE_NOPUT | MPI_MODE_NOSUCCEED, start_offset_win);
<a name="l00248"></a>00248         MPI_Win_fence(MPI_MODE_NOPUT | MPI_MODE_NOSUCCEED, idx_win);
<a name="l00249"></a>00249         MPI_Win_fence(MPI_MODE_NOPUT | MPI_MODE_NOSUCCEED, val_win);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251         MPI_Win_free(&amp;start_offset_win);
<a name="l00252"></a>00252         MPI_Win_free(&amp;idx_win);
<a name="l00253"></a>00253         MPI_Win_free(&amp;val_win);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="keyword">inline</span> index_type getPos(index_type rowid, index_type colid, <span class="keywordtype">size_t</span> ncols,
<a name="l00257"></a>00257         columnwise_tag)<span class="keyword"> const </span>{
<a name="l00258"></a>00258         <span class="keywordflow">return</span> colid + ncols * <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html#ac156c21c1adaeadc91f204d4556ba9c5">data_type::row_idx</a>[rowid];
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     <span class="keyword">inline</span> index_type getPos(index_type rowid, index_type colid, <span class="keywordtype">size_t</span> ncols,
<a name="l00262"></a>00262         rowwise_tag)<span class="keyword"> const </span>{
<a name="l00263"></a>00263         <span class="keywordflow">return</span> rowid * ncols + <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html#ac156c21c1adaeadc91f204d4556ba9c5">data_type::row_idx</a>[colid];
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265 };
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="comment">/* Specialization: SpParMat for input, Local Elemental output */</span>
<a name="l00268"></a>00268 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> IndexType,
<a name="l00269"></a>00269           <span class="keyword">typename</span> ValueType,
<a name="l00270"></a>00270           <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>IdxDistributionType,
<a name="l00271"></a>00271           <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>ValueDistribution&gt;
<a name="l00272"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html">00272</a> <span class="keyword">struct </span><a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html">hash_transform_t</a> &lt;
<a name="l00273"></a>00273     SpParMat&lt;IndexType, ValueType, SpDCCols&lt;IndexType, ValueType&gt; &gt;,
<a name="l00274"></a>00274     elem::<a class="code" href="../../dc/d74/capi_8cpp.html#aa267ec3ee50656a3303b4045e7010131">Matrix</a>&lt;ValueType&gt;,
<a name="l00275"></a>00275     IdxDistributionType,
<a name="l00276"></a>00276     ValueDistribution &gt; :
<a name="l00277"></a>00277         <span class="keyword">public</span> <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">hash_transform_data_t</a>&lt;IdxDistributionType,
<a name="l00278"></a>00278                                      ValueDistribution&gt; {
<a name="l00279"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a7e702b67d1af0e198272bd002ab92d4e">00279</a>     <span class="keyword">typedef</span> IndexType <a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a7e702b67d1af0e198272bd002ab92d4e">index_type</a>;
<a name="l00280"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a715e4d9a7c24e41a199158a58f09adcd">00280</a>     <span class="keyword">typedef</span> ValueType <a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a715e4d9a7c24e41a199158a58f09adcd">value_type</a>;
<a name="l00281"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a4787f6b8c04b03687c4e5665b963e591">00281</a>     <span class="keyword">typedef</span> SpDCCols&lt; index_type, value_type &gt; <a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a4787f6b8c04b03687c4e5665b963e591">col_t</a>;
<a name="l00282"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a73e36db62c784df0d21be27cbfd9ee62">00282</a>     <span class="keyword">typedef</span> FullyDistVec&lt; index_type, value_type&gt; <a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a73e36db62c784df0d21be27cbfd9ee62">mpi_vector_t</a>;
<a name="l00283"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a8c461b1bc5dfe0c364254707e2c8971b">00283</a>     <span class="keyword">typedef</span> SpParMat&lt; index_type, value_type, col_t &gt; <a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a8c461b1bc5dfe0c364254707e2c8971b">matrix_type</a>;
<a name="l00284"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a44d2c9336b99aa88bdded30802b8dabf">00284</a>     <span class="keyword">typedef</span> elem::Matrix&lt; value_type &gt; <a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a44d2c9336b99aa88bdded30802b8dabf">output_matrix_type</a>;
<a name="l00285"></a>00285     <span class="keyword">typedef</span> <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">hash_transform_data_t</a>&lt;IdxDistributionType,
<a name="l00286"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a9a7513651189407c36e2d5206ba9b39b">00286</a>                                   ValueDistribution&gt; <a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a9a7513651189407c36e2d5206ba9b39b">data_type</a>;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 
<a name="l00292"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a130a6a90950e763b967a26e735576d8f">00292</a>     <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a170fc8a64798cd59452b2a703348143e">hash_transform_t</a> (<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> S, <a class="code" href="../../de/dea/structskylark_1_1base_1_1context__t.html">base::context_t</a>&amp; context) :
<a name="l00293"></a>00293         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">data_type</a>(N, S, context) {
<a name="l00294"></a>00294 
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296 
<a name="l00300"></a>00300     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputMatrixType,
<a name="l00301"></a>00301               <span class="keyword">typename</span> OutputMatrixType&gt;
<a name="l00302"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#aa43f340fb0119ed602790d46f5e9b76b">00302</a>     <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a170fc8a64798cd59452b2a703348143e">hash_transform_t</a> (<a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html">hash_transform_t</a>&lt;InputMatrixType,
<a name="l00303"></a>00303                                        OutputMatrixType,
<a name="l00304"></a>00304                                        IdxDistributionType,
<a name="l00305"></a>00305                                        ValueDistribution&gt;&amp; other) :
<a name="l00306"></a>00306         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">data_type</a>(other) {}
<a name="l00307"></a>00307 
<a name="l00311"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a6a7aea426abc8588a8564834198fc406">00311</a>     <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a170fc8a64798cd59452b2a703348143e">hash_transform_t</a> (<a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">hash_transform_data_t</a>&lt;IdxDistributionType,
<a name="l00312"></a>00312                                             ValueDistribution&gt;&amp; other_data) :
<a name="l00313"></a>00313         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">data_type</a>(other_data) {}
<a name="l00314"></a>00314 
<a name="l00315"></a>00315     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dimension&gt;
<a name="l00316"></a><a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a600649271c0e60343be0837216501ba6">00316</a>     <span class="keywordtype">void</span> <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#ac899bcbff87aa859ada4b0e2f7705205">apply</a> (<span class="keyword">const</span> <a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a8c461b1bc5dfe0c364254707e2c8971b">matrix_type</a> &amp;A, <a class="code" href="../../d1/d03/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD00c99402890e90d0ad5d07d8ba674883.html#a44d2c9336b99aa88bdded30802b8dabf">output_matrix_type</a> &amp;sketch_of_A,
<a name="l00317"></a>00317                 Dimension dimension)<span class="keyword"> const </span>{
<a name="l00318"></a>00318         <span class="keywordflow">try</span> {
<a name="l00319"></a>00319             apply_impl (A, sketch_of_A, dimension);
<a name="l00320"></a>00320         } <span class="keywordflow">catch</span>(boost::mpi::exception e) {
<a name="l00321"></a>00321             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00322"></a>00322                 <a class="code" href="../../dc/d20/structskylark_1_1base_1_1mpi__exception.html" title="exceptions thrown by Boost MPI">base::mpi_exception</a>()
<a name="l00323"></a>00323                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(e.what()) );
<a name="l00324"></a>00324         } <span class="keywordflow">catch</span> (std::string e) {
<a name="l00325"></a>00325             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00326"></a>00326                 <a class="code" href="../../de/dbd/structskylark_1_1base_1_1combblas__exception.html" title="exceptions thrown by CombBLAS">base::combblas_exception</a>()
<a name="l00327"></a>00327                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(e) );
<a name="l00328"></a>00328         } <span class="keywordflow">catch</span> (std::logic_error e) {
<a name="l00329"></a>00329             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00330"></a>00330                 <a class="code" href="../../de/dbd/structskylark_1_1base_1_1combblas__exception.html" title="exceptions thrown by CombBLAS">base::combblas_exception</a>()
<a name="l00331"></a>00331                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(e.what()) );
<a name="l00332"></a>00332         } <span class="keywordflow">catch</span> (std::bad_alloc e) {
<a name="l00333"></a>00333             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00334"></a>00334                 <a class="code" href="../../d4/d8e/structskylark_1_1base_1_1skylark__exception.html" title="define a base exception">base::skylark_exception</a>()
<a name="l00335"></a>00335                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(<span class="stringliteral">&quot;bad_alloc: out of memory&quot;</span>) );
<a name="l00336"></a>00336         }
<a name="l00337"></a>00337     }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 
<a name="l00340"></a>00340 <span class="keyword">private</span>:
<a name="l00344"></a>00344     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dimension&gt;
<a name="l00345"></a>00345     <span class="keywordtype">void</span> apply_impl (<span class="keyword">const</span> <a class="code" href="../../d8/d1e/regression_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a> &amp;A_,
<a name="l00346"></a>00346         <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a4d90fe83e2669e836dacfa17e1b29213">output_matrix_type</a> &amp;sketch_of_A,
<a name="l00347"></a>00347         Dimension dist)<span class="keyword"> const </span>{
<a name="l00348"></a>00348 
<a name="l00349"></a>00349         <span class="comment">// We are essentially doing a &#39;const&#39; access to A, but the necessary,</span>
<a name="l00350"></a>00350         <span class="comment">// &#39;const&#39; option is missing from the interface</span>
<a name="l00351"></a>00351         <a class="code" href="../../d8/d1e/regression_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a> &amp;A = <span class="keyword">const_cast&lt;</span><a class="code" href="../../d8/d1e/regression_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a>&amp;<span class="keyword">&gt;</span>(A_);
<a name="l00352"></a>00352 
<a name="l00353"></a>00353         <span class="keyword">const</span> <span class="keywordtype">size_t</span> rank = A.getcommgrid()-&gt;GetRank();
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         <span class="comment">// extract columns of matrix</span>
<a name="l00356"></a>00356         <a class="code" href="../../dc/d74/capi_8cpp.html#ac21a17a4a9d7c56130fbacaeaf5b44c8">col_t</a> &amp;data = A.seq();
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         <span class="keyword">const</span> <span class="keywordtype">size_t</span> my_row_offset = utility::cb_my_row_offset(A);
<a name="l00359"></a>00359         <span class="keyword">const</span> <span class="keywordtype">size_t</span> my_col_offset = utility::cb_my_col_offset(A);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361         <span class="keywordtype">int</span> n_res_cols = A.getncol();
<a name="l00362"></a>00362         <span class="keywordtype">int</span> n_res_rows = A.getnrow();
<a name="l00363"></a>00363         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html#a9099e9c54fa7c096926dbfa5bd2c3416">data_type::get_res_size</a>(n_res_rows, n_res_cols, dist);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365         <span class="comment">// Apply sketch for all local values. Subsequently, all values are</span>
<a name="l00366"></a>00366         <span class="comment">// gathered on processor 0 and the local matrix is populated.</span>
<a name="l00367"></a>00367         <span class="keyword">typedef</span> std::map&lt;index_type, value_type&gt; col_values_t;
<a name="l00368"></a>00368         col_values_t col_values;
<a name="l00369"></a>00369         <span class="keywordflow">for</span>(<span class="keyword">typename</span> col_t::SpColIter col = data.begcol();
<a name="l00370"></a>00370             col != data.endcol(); col++) {
<a name="l00371"></a>00371             <span class="keywordflow">for</span>(<span class="keyword">typename</span> col_t::SpColIter::NzIter nz = data.begnz(col);
<a name="l00372"></a>00372                 nz != data.endnz(col); nz++) {
<a name="l00373"></a>00373 
<a name="l00374"></a>00374                 index_type rowid = nz.rowid()  + my_row_offset;
<a name="l00375"></a>00375                 index_type colid = col.colid() + my_col_offset;
<a name="l00376"></a>00376 
<a name="l00377"></a>00377                 <span class="keyword">const</span> value_type value =
<a name="l00378"></a>00378                     nz.value() * <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html#a67da8cff5cfd14ff5b993f5c4b33e9dc">data_type::getValue</a>(rowid, colid, dist);
<a name="l00379"></a>00379                 <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html#a2bc8b5d90f2ee4df005edc19cc2ee9fc">data_type::finalPos</a>(rowid, colid, dist);
<a name="l00380"></a>00380                 col_values[colid * n_res_rows + rowid] += value;
<a name="l00381"></a>00381             }
<a name="l00382"></a>00382         }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         std::vector&lt; std::map&lt;index_type, value_type &gt; &gt; result;
<a name="l00385"></a>00385         boost::mpi::gather(<a class="code" href="../../db/d39/namespaceskylark_1_1utility.html#a603e0fe4127da3887ceed891a58b3d38">utility::get_communicator</a>(A), col_values, result, 0);
<a name="l00386"></a>00386 
<a name="l00387"></a>00387         <span class="keywordflow">if</span>(rank == 0) {
<a name="l00388"></a>00388             <span class="keyword">typedef</span> <span class="keyword">typename</span> std::map&lt;index_type, value_type&gt;::iterator itr_t;
<a name="l00389"></a>00389             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; result.size(); ++i) {
<a name="l00390"></a>00390                 itr_t proc_itr = result[i].begin();
<a name="l00391"></a>00391                 <span class="keywordflow">for</span>(; proc_itr != result[i].end(); proc_itr++) {
<a name="l00392"></a>00392                     <span class="keywordtype">int</span> row = proc_itr-&gt;first % n_res_rows;
<a name="l00393"></a>00393                     <span class="keywordtype">int</span> col = proc_itr-&gt;first / n_res_rows;
<a name="l00394"></a>00394                     sketch_of_A.Update(row, col, proc_itr-&gt;second);
<a name="l00395"></a>00395                 }
<a name="l00396"></a>00396             }
<a name="l00397"></a>00397         }
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399 };
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 <span class="comment">/* Specialization: SpParMat for input, Elemental[* / *] output */</span>
<a name="l00403"></a>00403 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> IndexType,
<a name="l00404"></a>00404           <span class="keyword">typename</span> ValueType,
<a name="l00405"></a>00405           <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>IdxDistributionType,
<a name="l00406"></a>00406           <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>ValueDistribution&gt;
<a name="l00407"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html">00407</a> <span class="keyword">struct </span><a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html">hash_transform_t</a> &lt;
<a name="l00408"></a>00408     SpParMat&lt;IndexType, ValueType, SpDCCols&lt;IndexType, ValueType&gt; &gt;,
<a name="l00409"></a>00409     elem::<a class="code" href="../../dc/d74/capi_8cpp.html#a19350ba69c004b01dece9951a3477dc9">DistMatrix</a>&lt;ValueType, elem::STAR, elem::STAR&gt;,
<a name="l00410"></a>00410     IdxDistributionType,
<a name="l00411"></a>00411     ValueDistribution &gt; :
<a name="l00412"></a>00412         <span class="keyword">public</span> <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">hash_transform_data_t</a>&lt;IdxDistributionType,
<a name="l00413"></a>00413                                      ValueDistribution&gt; {
<a name="l00414"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a80bbe3baa132606adb6271ff1a34104d">00414</a>     <span class="keyword">typedef</span> IndexType <a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a80bbe3baa132606adb6271ff1a34104d">index_type</a>;
<a name="l00415"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a816acf24fc6925a9c3c906f343c8a737">00415</a>     <span class="keyword">typedef</span> ValueType <a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a816acf24fc6925a9c3c906f343c8a737">value_type</a>;
<a name="l00416"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#afdcdbfb278aae499cc1291c7d4a8001b">00416</a>     <span class="keyword">typedef</span> SpDCCols&lt; index_type, value_type &gt; <a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#afdcdbfb278aae499cc1291c7d4a8001b">col_t</a>;
<a name="l00417"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a1c83f5e7b9ec56dd9323dca9b93f1818">00417</a>     <span class="keyword">typedef</span> FullyDistVec&lt; index_type, value_type&gt; <a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a1c83f5e7b9ec56dd9323dca9b93f1818">mpi_vector_t</a>;
<a name="l00418"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#ad45dff311c9ec6fcf0311284240a99e1">00418</a>     <span class="keyword">typedef</span> SpParMat&lt; index_type, value_type, col_t &gt; <a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#ad45dff311c9ec6fcf0311284240a99e1">matrix_type</a>;
<a name="l00419"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a9b7ec08a088415ea9d4adced1d8eb3d9">00419</a>     <span class="keyword">typedef</span> elem::DistMatrix&lt; value_type, elem::STAR, elem::STAR &gt; <a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a9b7ec08a088415ea9d4adced1d8eb3d9">output_matrix_type</a>;
<a name="l00420"></a>00420     <span class="keyword">typedef</span> <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">hash_transform_data_t</a>&lt;IdxDistributionType,
<a name="l00421"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a52e7b83672b4bdc3113e8c643106a8b0">00421</a>                                   ValueDistribution&gt; <a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a52e7b83672b4bdc3113e8c643106a8b0">data_type</a>;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 
<a name="l00427"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a9315a73ee6a8d62bff8c5e4fc91d08fa">00427</a>     <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a170fc8a64798cd59452b2a703348143e">hash_transform_t</a> (<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> S, <a class="code" href="../../de/dea/structskylark_1_1base_1_1context__t.html">base::context_t</a>&amp; context) :
<a name="l00428"></a>00428         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">data_type</a>(N, S, context) {
<a name="l00429"></a>00429 
<a name="l00430"></a>00430     }
<a name="l00431"></a>00431 
<a name="l00435"></a>00435     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputMatrixType,
<a name="l00436"></a>00436               <span class="keyword">typename</span> OutputMatrixType&gt;
<a name="l00437"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a1ff0056102b8293f070f836b3ddfc8d7">00437</a>     <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a170fc8a64798cd59452b2a703348143e">hash_transform_t</a> (<a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html">hash_transform_t</a>&lt;InputMatrixType,
<a name="l00438"></a>00438                                        OutputMatrixType,
<a name="l00439"></a>00439                                        IdxDistributionType,
<a name="l00440"></a>00440                                        ValueDistribution&gt;&amp; other) :
<a name="l00441"></a>00441         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">data_type</a>(other) {}
<a name="l00442"></a>00442 
<a name="l00446"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a1ad40bfedfb8c46a281553f38ecd10ae">00446</a>     <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a170fc8a64798cd59452b2a703348143e">hash_transform_t</a> (<a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">hash_transform_data_t</a>&lt;IdxDistributionType,
<a name="l00447"></a>00447                                             ValueDistribution&gt;&amp; other_data) :
<a name="l00448"></a>00448         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html">data_type</a>(other_data) {}
<a name="l00449"></a>00449 
<a name="l00450"></a>00450     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dimension&gt;
<a name="l00451"></a><a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a3cf8318f0251413eb87e9381720047bc">00451</a>     <span class="keywordtype">void</span> <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#ac899bcbff87aa859ada4b0e2f7705205">apply</a> (<span class="keyword">const</span> <a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#ad45dff311c9ec6fcf0311284240a99e1">matrix_type</a> &amp;A, <a class="code" href="../../de/d4b/structskylark_1_1sketch_1_1hash__transform__t_3_01SpParMat_3_01IndexType_00_01ValueType_00_01SpD8725c73535fb9acfb69b6acf001afdd4.html#a9b7ec08a088415ea9d4adced1d8eb3d9">output_matrix_type</a> &amp;sketch_of_A,
<a name="l00452"></a>00452                 Dimension dimension)<span class="keyword"> const </span>{
<a name="l00453"></a>00453         <span class="keywordflow">try</span> {
<a name="l00454"></a>00454             apply_impl (A, sketch_of_A, dimension);
<a name="l00455"></a>00455         } <span class="keywordflow">catch</span>(boost::mpi::exception e) {
<a name="l00456"></a>00456             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00457"></a>00457                 <a class="code" href="../../dc/d20/structskylark_1_1base_1_1mpi__exception.html" title="exceptions thrown by Boost MPI">base::mpi_exception</a>()
<a name="l00458"></a>00458                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(e.what()) );
<a name="l00459"></a>00459         } <span class="keywordflow">catch</span> (std::string e) {
<a name="l00460"></a>00460             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00461"></a>00461                 <a class="code" href="../../de/dbd/structskylark_1_1base_1_1combblas__exception.html" title="exceptions thrown by CombBLAS">base::combblas_exception</a>()
<a name="l00462"></a>00462                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(e) );
<a name="l00463"></a>00463         } <span class="keywordflow">catch</span> (std::logic_error e) {
<a name="l00464"></a>00464             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00465"></a>00465                 <a class="code" href="../../de/dbd/structskylark_1_1base_1_1combblas__exception.html" title="exceptions thrown by CombBLAS">base::combblas_exception</a>()
<a name="l00466"></a>00466                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(e.what()) );
<a name="l00467"></a>00467         } <span class="keywordflow">catch</span> (std::bad_alloc e) {
<a name="l00468"></a>00468             <a class="code" href="../../d7/d1e/exception_8hpp.html#abedcc0a2ddc8fa567e3edcaa3fc1d62c" title="throw a skylark exception including file/line information">SKYLARK_THROW_EXCEPTION</a> (
<a name="l00469"></a>00469                 <a class="code" href="../../d4/d8e/structskylark_1_1base_1_1skylark__exception.html" title="define a base exception">base::skylark_exception</a>()
<a name="l00470"></a>00470                     &lt;&lt; <a class="code" href="../../d3/d18/namespaceskylark_1_1base.html#a797044780de82fcf917d87e0888763c3" title="predefined structure for error msg">base::error_msg</a>(<span class="stringliteral">&quot;bad_alloc: out of memory&quot;</span>) );
<a name="l00471"></a>00471         }
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="keyword">private</span>:
<a name="l00479"></a>00479     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dimension&gt;
<a name="l00480"></a>00480     <span class="keywordtype">void</span> apply_impl (<span class="keyword">const</span> <a class="code" href="../../d8/d1e/regression_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a> &amp;A_,
<a name="l00481"></a>00481         <a class="code" href="../../d0/dca/structskylark_1_1sketch_1_1hash__transform__t.html#a4d90fe83e2669e836dacfa17e1b29213">output_matrix_type</a> &amp;sketch_of_A,
<a name="l00482"></a>00482         Dimension dist)<span class="keyword"> const </span>{
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         <span class="comment">// We are essentially doing a &#39;const&#39; access to A, but the necessary,</span>
<a name="l00485"></a>00485         <span class="comment">// &#39;const&#39; option is missing from the interface</span>
<a name="l00486"></a>00486         <a class="code" href="../../d8/d1e/regression_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a> &amp;A = <span class="keyword">const_cast&lt;</span><a class="code" href="../../d8/d1e/regression_8cpp.html#ab8e88f4957c67881617f8fd9ba9099e6">matrix_type</a>&amp;<span class="keyword">&gt;</span>(A_);
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <span class="keyword">const</span> <span class="keywordtype">size_t</span> rank = A.getcommgrid()-&gt;GetRank();
<a name="l00489"></a>00489 
<a name="l00490"></a>00490         <span class="comment">// extract columns of matrix</span>
<a name="l00491"></a>00491         <a class="code" href="../../dc/d74/capi_8cpp.html#ac21a17a4a9d7c56130fbacaeaf5b44c8">col_t</a> &amp;data = A.seq();
<a name="l00492"></a>00492 
<a name="l00493"></a>00493         <span class="keyword">const</span> <span class="keywordtype">size_t</span> my_row_offset = utility::cb_my_row_offset(A);
<a name="l00494"></a>00494         <span class="keyword">const</span> <span class="keywordtype">size_t</span> my_col_offset = utility::cb_my_col_offset(A);
<a name="l00495"></a>00495 
<a name="l00496"></a>00496         <span class="keywordtype">int</span> n_res_cols = A.getncol();
<a name="l00497"></a>00497         <span class="keywordtype">int</span> n_res_rows = A.getnrow();
<a name="l00498"></a>00498         <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html#a9099e9c54fa7c096926dbfa5bd2c3416">data_type::get_res_size</a>(n_res_rows, n_res_cols, dist);
<a name="l00499"></a>00499 
<a name="l00500"></a>00500         <span class="comment">// Apply sketch for all local values. Subsequently, all values are</span>
<a name="l00501"></a>00501         <span class="comment">// gathered on all processor and the &quot;local&quot; matrix is populated.</span>
<a name="l00502"></a>00502         <span class="keyword">typedef</span> std::map&lt;index_type, value_type&gt; col_values_t;
<a name="l00503"></a>00503         col_values_t col_values;
<a name="l00504"></a>00504         <span class="keywordflow">for</span>(<span class="keyword">typename</span> col_t::SpColIter col = data.begcol();
<a name="l00505"></a>00505             col != data.endcol(); col++) {
<a name="l00506"></a>00506             <span class="keywordflow">for</span>(<span class="keyword">typename</span> col_t::SpColIter::NzIter nz = data.begnz(col);
<a name="l00507"></a>00507                 nz != data.endnz(col); nz++) {
<a name="l00508"></a>00508 
<a name="l00509"></a>00509                 index_type rowid = nz.rowid()  + my_row_offset;
<a name="l00510"></a>00510                 index_type colid = col.colid() + my_col_offset;
<a name="l00511"></a>00511 
<a name="l00512"></a>00512                 <span class="keyword">const</span> value_type value =
<a name="l00513"></a>00513                     nz.value() * <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html#a67da8cff5cfd14ff5b993f5c4b33e9dc">data_type::getValue</a>(rowid, colid, dist);
<a name="l00514"></a>00514                 <a class="code" href="../../da/dbf/structskylark_1_1sketch_1_1hash__transform__data__t.html#a2bc8b5d90f2ee4df005edc19cc2ee9fc">data_type::finalPos</a>(rowid, colid, dist);
<a name="l00515"></a>00515                 col_values[colid * n_res_rows + rowid] += value;
<a name="l00516"></a>00516             }
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         std::vector&lt; std::map&lt;index_type, value_type &gt; &gt; result;
<a name="l00520"></a>00520         boost::mpi::all_gather(
<a name="l00521"></a>00521                 <a class="code" href="../../db/d39/namespaceskylark_1_1utility.html#a603e0fe4127da3887ceed891a58b3d38">utility::get_communicator</a>(A), col_values, result);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::map&lt;index_type, value_type&gt;::iterator itr_t;
<a name="l00524"></a>00524         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; result.size(); ++i) {
<a name="l00525"></a>00525             itr_t proc_itr = result[i].begin();
<a name="l00526"></a>00526             <span class="keywordflow">for</span>(; proc_itr != result[i].end(); proc_itr++) {
<a name="l00527"></a>00527                 <span class="keywordtype">int</span> row = proc_itr-&gt;first % n_res_rows;
<a name="l00528"></a>00528                 <span class="keywordtype">int</span> col = proc_itr-&gt;first / n_res_rows;
<a name="l00529"></a>00529                 sketch_of_A.Update(row, col, proc_itr-&gt;second);
<a name="l00530"></a>00530             }
<a name="l00531"></a>00531         }
<a name="l00532"></a>00532     }
<a name="l00533"></a>00533 };
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 } } 
<a name="l00537"></a>00537 <span class="preprocessor">#endif // SKYLARK_HASH_TRANSFORM_MIXED_HPP</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 02:49:11 for Skylark (Sketching Library) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
