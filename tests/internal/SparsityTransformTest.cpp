#include <vector>

#include <elemental.hpp>

#include "../../sketch/CWT.hpp"

//#define BOOST_TEST_MODULE SparseSketches
//#include <boost/test/unit_test.hpp>

#include <boost/mpi.hpp>
#include <boost/test/minimal.hpp>


//BOOST_AUTO_TEST_CASE( Sparse_CWT_Test ) {
int test_main(int argc, char *argv[]) {

    namespace mpi = boost::mpi;

    /** Typedef DistMatrix and Matrix */
    typedef std::vector<int> IntContainer;
    typedef std::vector<double> DblContainer;
    typedef elem::Matrix<double> MatrixType;
    typedef elem::DistMatrix<double, elem::VR, elem::STAR> DistMatrixType;

    mpi::environment env (argc, argv);
    mpi::communicator world;

    elem::Initialize (argc, argv);
    MPI_Comm mpi_world(world);
    elem::Grid grid (mpi_world);

    skylark::sketch::context_t context (0, world);

    double count = 1.0;
    elem::DistMatrix<double, elem::VR, elem::STAR> A(grid);
    elem::Uniform (A, 10, 5);
    for( size_t j = 0; j < A.Height(); j++ )
        for( size_t i = 0; i < A.Width(); i++ )
            A.Set(j, i, count++);

    //////////////////////////////////////////////////////////////////////////
    //[> Column wise application <]

    // PI generated by random number gen
    elem::DistMatrix<double, elem::VR, elem::STAR> pi_sketch(grid);
    elem::Uniform(pi_sketch, 6, 10);
    elem::Zero(pi_sketch);
    pi_sketch.Set(5, 0,  1.0);
    pi_sketch.Set(3, 1, -1.0);
    pi_sketch.Set(3, 2, -1.0);
    pi_sketch.Set(1, 3,  1.0);
    pi_sketch.Set(1, 4, -1.0);
    pi_sketch.Set(5, 5, -1.0);
    pi_sketch.Set(3, 6, -1.0);
    pi_sketch.Set(0, 7, -1.0);
    pi_sketch.Set(4, 8,  1.0);
    pi_sketch.Set(2, 9, -1.0);

    /* 1. Create the sketching matrix */
    skylark::sketch::CWT_t<DistMatrixType, MatrixType>
        Sparse (10, 6, context);

    /* 2. Create space for the sketched matrix */
    MatrixType sketch_A(6, 5);

    /* 3. Apply the transform */
    Sparse.apply (A, sketch_A, skylark::sketch::columnwise_tag());

    /* 4. Build structure to compare */
    elem::DistMatrix<double, elem::VR, elem::STAR> expected_A(grid);
    elem::Uniform (expected_A, 6, 5);
    elem::Gemm(elem::NORMAL, elem::NORMAL,
               1.0, pi_sketch.LockedMatrix(), A.LockedMatrix(),
               0.0, expected_A.Matrix());

    for(size_t j = 0; j < sketch_A.Height(); j++ )
        for(size_t i = 0; i < sketch_A.Width(); i++ )
            if(sketch_A.Get(j, i) != expected_A.Get(j,i))
                BOOST_FAIL("Result of colwise application not as expected");



    //////////////////////////////////////////////////////////////////////////
    //[> Row wise application <]

    // PI^T generated by random number gen
    elem::DistMatrix<double, elem::VR, elem::STAR> pi_sketch_r(grid);
    elem::Uniform(pi_sketch_r, 5, 3);
    elem::Zero(pi_sketch_r);
    pi_sketch_r.Set(0, 2, -1.0);
    pi_sketch_r.Set(1, 0, -1.0);
    pi_sketch_r.Set(2, 1,  1.0);
    pi_sketch_r.Set(3, 2, -1.0);
    pi_sketch_r.Set(4, 0,  1.0);

    //[> 1. Create the sketching matrix <]
    skylark::sketch::CWT_t<DistMatrixType, MatrixType>
        Sparse_r (5, 3, context);

    //[> 2. Create space for the sketched matrix <]
    MatrixType sketch_A_r(10, 3);

    //[> 3. Apply the transform <]
    Sparse_r.apply (A, sketch_A_r, skylark::sketch::rowwise_tag());

    /* 4. Build structure to compare */
    elem::DistMatrix<double, elem::VR, elem::STAR> expected_AR(grid);
    elem::Uniform (expected_AR, 10, 3);
    elem::Gemm(elem::NORMAL, elem::NORMAL,
               1.0, A.LockedMatrix(), pi_sketch_r.Matrix(),
               0.0, expected_AR.Matrix());

    for(size_t j = 0; j < sketch_A_r.Height(); j++ )
        for(size_t i = 0; i < sketch_A_r.Width(); i++ )
            if(sketch_A_r.Get(j, i) != expected_AR.Get(j,i))
                BOOST_FAIL("Result of rowwise application not as expected");


    elem::Finalize();
    return 0;
}
