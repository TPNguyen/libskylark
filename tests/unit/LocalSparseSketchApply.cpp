/**
 *  This test ensures that the sketch application (for CombBLAS matrices) is
 *  done correctly (on-the-fly matrix multiplication in the code is compared
 *  to true matrix multiplication).
 *  This test builds on the following assumptions:
 *
 *      - CombBLAS PSpGEMM returns the correct result, and
 *      - the random numbers in row_idx and row_value (see
 *        hash_transform_data_t) are drawn from the promised distributions.
 */


#include <vector>

#include <boost/mpi.hpp>
#include <boost/test/minimal.hpp>

#include "../../utility/distributions.hpp"
#include "../../base/sparse_matrix.hpp"
#include "../../sketch/context.hpp"
#include "../../sketch/hash_transform.hpp"


template < typename InputMatrixType,
           typename OutputMatrixType = InputMatrixType >
struct Dummy_t : public skylark::sketch::hash_transform_t<
    InputMatrixType, OutputMatrixType,
    boost::random::uniform_int_distribution,
    skylark::utility::rademacher_distribution_t > {

    typedef skylark::sketch::hash_transform_t<
        InputMatrixType, OutputMatrixType,
        boost::random::uniform_int_distribution,
        skylark::utility::rademacher_distribution_t >
            hash_t;

    Dummy_t(int N, int S, skylark::sketch::context_t& context)
        : skylark::sketch::hash_transform_t<InputMatrixType, OutputMatrixType,
          boost::random::uniform_int_distribution,
          skylark::utility::rademacher_distribution_t>(N, S, context)
    {}

    std::vector<size_t> getRowIdx() { return hash_t::row_idx; }
    std::vector<double> getRowValues() { return hash_t::row_value; }
};

int test_main(int argc, char *argv[]) {

    //////////////////////////////////////////////////////////////////////////
    //[> Parameters <]

    //FIXME: use random sizes?
    const size_t n   = 10;
    const size_t m   = 5;
    const size_t n_s = 6;
    const size_t m_s = 3;

    typedef skylark::base::sparse_matrix_t<double> Matrix_t;

    //////////////////////////////////////////////////////////////////////////
    //[> Setup test <]

    namespace mpi = boost::mpi;
    mpi::environment env(argc, argv);
    mpi::communicator world;
    const size_t rank = world.rank();

    skylark::sketch::context_t context (0, world);

    double count = 1.0;

    const int matrix_full = n * m;
    std::vector<int> colsf(m + 1);
    std::vector<int> rowsf(matrix_full);
    std::vector<double> valsf(matrix_full);

    for(size_t i = 0; i < m + 1; ++i)
        colsf[i] = i * n;

    for(size_t i = 0; i < matrix_full; ++i) {
        rowsf[i] = i % n;
        valsf[i] = count;
        count++;
    }

    Matrix_t A;
    A.attach(&colsf[0], &rowsf[0], &valsf[0], m + 1, matrix_full, n, m);

    count = 1;
    typename Matrix_t::const_ind_itr_range_t citr = A.indptr_itr();
    typename Matrix_t::const_ind_itr_range_t ritr = A.indices_itr();
    typename Matrix_t::const_val_itr_range_t vitr = A.values_itr();

    for(; citr.first + 1 != citr.second; citr.first++) {
        for(int idx = 0; idx < (*(citr.first + 1) - *citr.first);
            vitr.first++, ++idx) {

            BOOST_REQUIRE( *vitr.first == count );
            count++;
        }
    }

    //////////////////////////////////////////////////////////////////////////
    //[> Column wise application <]

    //[> 1. Create the sketching matrix <]
    Dummy_t<Matrix_t, Matrix_t> Sparse(n, n_s, context);
    std::vector<size_t> row_idx = Sparse.getRowIdx();
    std::vector<double> row_val = Sparse.getRowValues();

    // PI generated by random number gen
    int sketch_size = row_val.size();
    std::vector<int> rows(sketch_size);
    std::vector<int> cols(sketch_size);
    std::vector<double> vals(sketch_size);

    typename Matrix_t::coords_t coords;
    for(int i = 0; i < sketch_size; ++i) {
        typename Matrix_t::coord_tuple_t new_entry(row_idx[i], i, row_val[i]);
        coords.push_back(new_entry);
    }

    Matrix_t pi_sketch;
    pi_sketch.attach(coords);

    //[> 2. Create sketched matrix <]
    Matrix_t sketch_A;

    //[> 3. Apply the transform <]
    Sparse.apply(A, sketch_A, skylark::sketch::columnwise_tag());

    //[> 4. Build structure to compare: PI * A ?= sketch_A <]
    size_t col = 0;
    typename Matrix_t::coords_t coords_new;
    citr = pi_sketch.indptr_itr();
    ritr = pi_sketch.indices_itr();
    vitr = pi_sketch.values_itr();

    // multiply with vector where an entry has the value:
    //   col_idx * n + row_idx + 1.
    // See creation of A.
    for(; citr.first + 1 != citr.second; citr.first++, ++col) {
        for(int idx = 0; idx < (*(citr.first + 1) - *citr.first);
            ritr.first++, vitr.first++, ++idx) {

            for(int ccol = 0; ccol < m; ++ccol) {

                typename Matrix_t::coord_tuple_t new_entry(*ritr.first, ccol,
                    *vitr.first * (ccol * n + col + 1));
                coords_new.push_back(new_entry);
            }
        }
    }

    Matrix_t expected_A;
    expected_A.attach(coords_new, n_s, m);

    if (!static_cast<bool>(expected_A == sketch_A))
        BOOST_FAIL("Result of colwise application not as expected");


/*
    //////////////////////////////////////////////////////////////////////////
    //[> Row wise application <]

    //[> 1. Create the sketching matrix <]
    //TODO
*/

    return 0;
}
