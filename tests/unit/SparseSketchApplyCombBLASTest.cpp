/**
 *  This test ensures that the sketch application (for CombBLAS matrices) is
 *  done correctly (on-the-fly matrix multiplication in the code is compared
 *  to true matrix multiplication).
 *  This test builds on the following assumptions:
 *
 *      - CombBLAS PSpGEMM returns the correct result, and
 *      - the random numbers in row_idx and row_value (see
 *        hash_transform_data_t) are drawn from the promised distributions.
 */


#include <vector>

#include <boost/mpi.hpp>
#include <boost/test/minimal.hpp>

#include "../../utility/distributions.hpp"
#include "../../sketch/context.hpp"
#include "../../sketch/hash_transform.hpp"


template < typename InputMatrixType,
           typename OutputMatrixType = InputMatrixType >
struct Dummy_t : public skylark::sketch::hash_transform_t<
    InputMatrixType, OutputMatrixType,
    boost::random::uniform_int_distribution,
    skylark::utility::rademacher_distribution_t > {

    typedef skylark::sketch::hash_transform_t<
        InputMatrixType, OutputMatrixType,
        boost::random::uniform_int_distribution,
        skylark::utility::rademacher_distribution_t >
            hash_t;

    Dummy_t(int N, int S, skylark::sketch::context_t& context)
        : skylark::sketch::hash_transform_t<InputMatrixType, OutputMatrixType,
          boost::random::uniform_int_distribution,
          skylark::utility::rademacher_distribution_t>(N, S, context)
    {}

    std::vector<size_t> getRowIdx() { return hash_t::row_idx; }
    std::vector<double> getRowValues() { return hash_t::row_value; }
};

int test_main(int argc, char *argv[]) {

    //////////////////////////////////////////////////////////////////////////
    //[> Parameters <]

    //FIXME: use random sizes?
    const size_t n   = 10;
    const size_t m   = 5;
    const size_t n_s = 6;
    const size_t m_s = 3;

    typedef FullyDistVec<size_t, double> mpi_vector_t;
    typedef SpDCCols<size_t, double> col_t;
    typedef SpParMat<size_t, double, col_t> DistMatrixType;
    typedef PlusTimesSRing<double, double> PTDD;

    //////////////////////////////////////////////////////////////////////////
    //[> Setup test <]
    namespace mpi = boost::mpi;
    mpi::environment env(argc, argv);
    mpi::communicator world;

    skylark::sketch::context_t context (0, world);

    double count = 1.0;

    const size_t matrix_full = n * m;
    mpi_vector_t colsf(matrix_full);
    mpi_vector_t rowsf(matrix_full);
    mpi_vector_t valsf(matrix_full);

    for(size_t i = 0; i < matrix_full; ++i) {
        colsf.SetElement(i, i % m);
        rowsf.SetElement(i, i / m);
        valsf.SetElement(i, count);
        count++;
    }

    DistMatrixType A(n, m, rowsf, colsf, valsf);

    //////////////////////////////////////////////////////////////////////////
    //[> Column wise application <]

    //[> 1. Create the sketching matrix <]
    Dummy_t<DistMatrixType, DistMatrixType> Sparse(n, n_s, context);
    std::vector<size_t> row_idx    = Sparse.getRowIdx();
    std::vector<double> row_val = Sparse.getRowValues();

    // PI generated by random number gen
    size_t sketch_size = row_val.size();
    mpi_vector_t cols(sketch_size);
    mpi_vector_t rows(sketch_size);
    mpi_vector_t vals(sketch_size);

    for(size_t i = 0; i < sketch_size; ++i) {
        cols.SetElement(i, i);
        rows.SetElement(i, row_idx[i]);
        vals.SetElement(i, row_val[i]);
    }

    DistMatrixType pi_sketch(n_s, n, rows, cols, vals);

    //[> 2. Create space for the sketched matrix <]
    mpi_vector_t zero;
    DistMatrixType sketch_A(n_s, n, zero, zero, zero);

    //[> 3. Apply the transform <]
    Sparse.apply(A, sketch_A, skylark::sketch::columnwise_tag());

    //[> 4. Build structure to compare <]
    DistMatrixType expected_A = PSpGEMM<PTDD>(pi_sketch, A);


    Arr<size_t, double> sk = sketch_A.seq().GetArrays();
    Arr<size_t, double> ex = expected_A.seq().GetArrays();

    for(size_t j = 0; j < 3; ++j)
        for(size_t i = 0; i < ex.indarrs[j].count; ++i)
            if(ex.indarrs[j].addr[i] != sk.indarrs[j].addr[i])
                BOOST_FAIL("Result of colwise application not as expected (indices differ)");

    for(size_t i = 0; i < ex.numarrs[0].count; ++i)
        if(ex.numarrs[0].addr[i] != sk.numarrs[0].addr[i])
            BOOST_FAIL("Result of colwise application not as expected (values differ)");



    //////////////////////////////////////////////////////////////////////////
    //[> Row wise application <]

    //[> 1. Create the sketching matrix <]
    Dummy_t<DistMatrixType, DistMatrixType> Sparse_r(m, m_s, context);
    row_idx.clear(); row_val.clear();
    row_idx = Sparse_r.getRowIdx();
    row_val = Sparse_r.getRowValues();

    //// PI^T generated by random number gen
    sketch_size = row_val.size();
    mpi_vector_t cols_r(sketch_size);
    mpi_vector_t rows_r(sketch_size);
    mpi_vector_t vals_r(sketch_size);

    for(size_t i = 0; i < sketch_size; ++i) {
        cols_r.SetElement(i, row_idx[i]);
        rows_r.SetElement(i, i);
        vals_r.SetElement(i, row_val[i]);
    }

    DistMatrixType pi_sketch_r(m, m_s, rows_r, cols_r, vals_r);

    //[> 2. Create space for the sketched matrix <]
    DistMatrixType sketch_A_r(n, m_s, zero, zero, zero);

    ////[> 3. Apply the transform <]
    Sparse_r.apply(A, sketch_A_r, skylark::sketch::rowwise_tag());

    //[> 4. Build structure to compare <]
    DistMatrixType expected_AR = PSpGEMM<PTDD>(A, pi_sketch_r);


    sk = sketch_A_r.seq().GetArrays();
    ex = expected_AR.seq().GetArrays();

    for(size_t j = 0; j < 3; ++j)
        for(size_t i = 0; i < ex.indarrs[j].count; ++i)
            if(ex.indarrs[j].addr[i] != sk.indarrs[j].addr[i])
                BOOST_FAIL("Result of rowwise application not as expected (indices differ)");

    for(size_t i = 0; i < ex.numarrs[0].count; ++i)
        if(ex.numarrs[0].addr[i] != sk.numarrs[0].addr[i])
            BOOST_FAIL("Result of rowwise application not as expected (values differ)");

    return 0;
}
